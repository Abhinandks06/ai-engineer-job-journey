[{"text": " \n \n  ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 1}}, {"text": "FastAPI \u2013 Python Web Framework \n \ni \n \n \nAbout the T utorial \nFastAPI is a modern Python web framework, very efficient in building APIs. \nFastAPI has been developed by Sebastian Ramirez in Dec. 2018. FastAPI \n0.68.0 is the currently available version. The latest version requires Python \n3.6 or above. It is one of the fastest web frameworks of Python. \nAudience \nThis tutorial is designed for developers who want to learn how to build REST \nAPIs using Python.  \nPrerequisites \nBefore you proceed, ma", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 2}}, {"text": "pers who want to learn how to build REST \nAPIs using Python.  \nPrerequisites \nBefore you proceed, make sure that you understand the basics of procedural \nand object -oriented programming in Python. Knowledge of REST \narchitecture is an added advantage. \nDisclaimer & Copyright \n\uf0e3 Copyright 2022 by Tutorials Point (I) Pvt. Ltd.  \nAll the conte nt and graphics published in this e -book are the property of \nTutorials Point (I) Pvt. Ltd. The user of this e -book is prohibited to reuse, \nretain, copy,", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 2}}, {"text": "ty of \nTutorials Point (I) Pvt. Ltd. The user of this e -book is prohibited to reuse, \nretain, copy, distribute or republish any contents or a part of contents of \nthis e-book in any manner without written consent of the publisher.   \nWe strive to update the contents of our website and tutorials as timely and \nas precisely as possible, however, the contents may contain inaccuracies or \nerrors. Tutorials Point (I) Pvt. Ltd. provides no guarantee regarding the \naccuracy, timeliness or completeness", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 2}}, {"text": "orials Point (I) Pvt. Ltd. provides no guarantee regarding the \naccuracy, timeliness or completeness of our website or its contents \nincluding this tutorial. If you discover any errors on our website or in this \ntutorial, please notify us at contact@tutorialspoint.com. \n \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 2}}, {"text": "FastAPI \u2013 Python Web Framework \n \nii \n \nT able of Contents \nAbout the Tutorial ........................................................................................................ i \nAudience ...................................................................................................................... i \nPrerequisites ................................................................................................................ i \nDisclaimer & Copyright .............................", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 3}}, {"text": "............................................ i \nDisclaimer & Copyright ................................................................................................. i \nTable of Contents ........................................................................................................ ii \n1. FASTAPI \u2013 INTRODUCTION ................................ ................................ ..........1 \nFastAPI \u2013 Environment Setup ....................................................................", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 3}}, {"text": ".1 \nFastAPI \u2013 Environment Setup ...................................................................................... 1 \n2. FASTAPI \u2013 HELLO WORLD ................................ ................................ ............3 \nGetting Started ............................................................................................................ 3 \n3. FASTAPI \u2013 OPENAPI ................................ ................................ .....................5 \n4. FASTAPI \u2013 UVICORN.............", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 3}}, {"text": "......... ................................ .....................5 \n4. FASTAPI \u2013 UVICORN................................ ................................ .....................9 \n5. FASTAPI \u2013 TYPE HINTS ................................ ................................ ...............12 \n6. FASTAPI \u2013 IDE SUPPORT ................................ ................................ ............16 \n7. FASTAPI \u2013 REST ARCHITECTURE ................................ ................................ .19 \n8. FA", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 3}}, {"text": "API \u2013 REST ARCHITECTURE ................................ ................................ .19 \n8. FASTAPI \u2013 PATH PARAMETERS ................................ ................................ ...20 \nCheck OpenAPI docs .................................................................................................. 22 \nPath Parameters with Types...................................................................................... 25 \n9. FASTAPI \u2013 QUERY PARAMETERS ................................ .", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 3}}, {"text": "............................... 25 \n9. FASTAPI \u2013 QUERY PARAMETERS ................................ ................................ 27 \n10. FASTAPI \u2013 PARAMETER VALIDATION ................................ ......................... 31 ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 3}}, {"text": "FastAPI \u2013 Python Web Framework \n \niii \n \n11. FASTAPI \u2013 PYDANTIC................................ ................................ ..................37 \n12. FASTAPI \u2013 REQUEST BODY ................................ ................................ .........40 \n13. FASTAPI \u2013 TEMPLATES ................................ ................................ ...............47 \n14. FASTAPI \u2013 STATIC FILES ................................ ................................ ..............52 \n15. FASTAPI \u2013 HTML FORM", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 4}}, {"text": "......................... ................................ ..............52 \n15. FASTAPI \u2013 HTML FORM TEMPLATES ................................ .......................... 56 \n16. FASTAPI \u2013 ACCESSING FORM DATA ................................ ........................... 58 \n17. FASTAPI \u2013 UPLOADING FILES ................................ ................................ .....60 \n18. FASTAPI \u2013 COOKIE PARAMETERS ................................ ............................... 62 \n19. FASTAPI \u2013 HEADER", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 4}}, {"text": "PARAMETERS ................................ ............................... 62 \n19. FASTAPI \u2013 HEADER PARAMETERS ................................ .............................. 65 \n20. FASTAPI \u2013 RESPONSE MODEL ................................ ................................ ....68 \n21. FASTAPI \u2013 NESTED MODELS ................................ ................................ ......71 \n22. FASTAPI \u2013 DEPENDENCIES ................................ ................................ .........75 \n23. FAS", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 4}}, {"text": " DEPENDENCIES ................................ ................................ .........75 \n23. FASTAPI \u2013 CORS ................................ ................................ ......................... 78 \n24. FASTAPI \u2013 CRUD OPERATIONS ................................ ................................ ...80 \n25. FASTAPI \u2013 SQL DATABASES ................................ ................................ ........88 \n26. FASTAPI \u2013 USING MONGODB ................................ ......................", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 4}}, {"text": ".... ........88 \n26. FASTAPI \u2013 USING MONGODB ................................ ................................ ....94 \n27. FASTAPI \u2013 USING GRAPHQL ................................ ................................ .......99 \n28. FASTAPI \u2013 WEBSOCKETS ................................ ................................ .......... 102 ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 4}}, {"text": "FastAPI \u2013 Python Web Framework \n \niv \n \n29. FASTAPI \u2013 FASTAPI EVENT HANDLERS ................................ ..................... 106 \n30. FASTAPI \u2013 MOUNTING A SUB-APP ................................ ...........................  108 \n31. FASTAPI \u2013 MIDDLEWARE ................................ ................................ ......... 111 \n32. FASTAPI \u2013 MOUNTING FLASK APP ................................ ...........................  113 \n33. FASTAPI \u2013 DEPLOYMENT ................................", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 5}}, {"text": "........ ...........................  113 \n33. FASTAPI \u2013 DEPLOYMENT ................................ ................................ ......... 115 ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 5}}, {"text": "FastAPI \u2013 Python Web Framework \n \n1 \n \nFastAPI is a modern Python web framework, very efficient in building APIs. \nIt is based on Python\u2019s type hints feature that has been added since Python \n3.6 onwards. It is one of the fastest web frameworks of Python.  \n\uf0b7 As it works on the functionality of Starlette and Pydantic libraries, its \nperformance is amongst the best and on par with that of NodeJS and \nGo.  \n \n\uf0b7 In addition to offering high performance, FastAPI offers significant \nspeed for develop", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 6}}, {"text": "d \nGo.  \n \n\uf0b7 In addition to offering high performance, FastAPI offers significant \nspeed for development, reduces human-induced errors in the code, \nis easy to learn and is completely production-ready.  \n \n\uf0b7 FastAPI is fully compatible with well -known standards of APIs, \nnamely OpenAPI and JSON schema. \nFastAPI has been developed by Sebastian Ramirez in Dec. 2018. FastAPI \n0.68.0 is the currently available version. \nFastAPI \u2013 Environment Setup \nTo install FastAPI (preferably in a virtual enviro", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 6}}, {"text": " available version. \nFastAPI \u2013 Environment Setup \nTo install FastAPI (preferably in a virtual environment), use pip installer. \npip3 install fastapi \nFastAPI depends on Starlette and Pydantic libraries, hence they also get \ninstalled.  \nInstalling Uvicorn using PIP \nFastAPI doesn\u2019t come with any built -in server application. To run FastAPI \napp, you need an ASGI server called uvicorn, so install the same too, using \npip installer. It will also install uvicorn\u2019s dependencies - asgiref, click, h11", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 6}}, {"text": "he same too, using \npip installer. It will also install uvicorn\u2019s dependencies - asgiref, click, h11, \nand typing-extensions \npip3 install uvicorn \nWith these two libraries installed, we can check all the libraries installed so \nfar. \n1. FastAPI \u2013 Introduction ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 6}}, {"text": "FastAPI \u2013 Python Web Framework \n \n2 \n \npip3 freeze \n \nasgiref==3.4.1 \nclick==8.0.1 \ncolorama==0.4.4 \nfastapi==0.68.0 \nh11==0.12.0 \nimportlib-metadata==4.6.4 \npydantic==1.8.2 \nstarlette==0.14.2 \ntyping-extensions==3.10.0.0 \nuvicorn==0.15.0 \nzipp==3.5.0 \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 7}}, {"text": "FastAPI \u2013 Python Web Framework \n \n3 \n \nGetting Started \nThe first step in creating a FastAPI app is to declare the application object \nof FastAPI class. \nfrom fastapi import FastAPI \napp = FastAPI() \nThis app object is the main point of interaction of the application with the \nclient browser. The uvicorn server uses this object to listen to client\u2019s \nrequest. \nThe next step is to create path operation. Path is a URL which when visited \nby the client invokes visits  a mapped URL to one of the HTT", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 8}}, {"text": "tion. Path is a URL which when visited \nby the client invokes visits  a mapped URL to one of the HTTP methods, an \nassociated function is to be executed.  We need to bind a view function to \na URL and the corresponding HTTP method. For example, the index() \nfunction corresponds to \u2018/\u2019 path with \u2018get\u2019 operation. \n@app.get(\"/\") \nasync def root(): \n    return {\"message\": \"Hello World\"} \nThe function returns a JSON response, however, it can return dict, list, \nstr, int, etc. It can also return Pydan", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 8}}, {"text": "returns a JSON response, however, it can return dict, list, \nstr, int, etc. It can also return Pydantic models. \nSave the following code as main.py \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.get(\"/\") \nasync def index(): \n    return {\"message\": \"Hello World\"} \n2. FastAPI \u2013 Hello World ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 8}}, {"text": "FastAPI \u2013 Python Web Framework \n \n4 \n \nStart the uvicorn server by mentioning the file in which the FastAPI \napplication object is instantiated. \nuvicorn main:app --reload \n \nINFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C \nto quit) \nINFO: Started reloader process [28720] \nINFO: Started server process [28722] \nINFO: Waiting for application startup. \nINFO: Application startup complete. \nOpen the browser and visit http://localhost:/8000. You will see the JSON \nresponse in the browser ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 9}}, {"text": " \nOpen the browser and visit http://localhost:/8000. You will see the JSON \nresponse in the browser window. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 9}}, {"text": "FastAPI \u2013 Python Web Framework \n \n5 \n \nEnter the following URL in the browser to generate automatically the \ninteractive documentation.  \nhttp://127.0.0.1:8000/docs \nFastAPI uses Swagger UI to produce  this documentation. The browser will \ndisplay the following: \n \n3. FastAPI \u2013 OpenAPI ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 10}}, {"text": "FastAPI \u2013 Python Web Framework \n \n6 \n \nClick the 'try it out' button and then ' Execute' button that appears \nafterward. \n \nYou can see the Curl command internally executed, the request URL, the \nresponse headers, and the JSON format of the server\u2019s response. \nFastAPI generates a schema using OpenAPI specifications. The \nspecification determines how to define API paths, path parameters, etc. The \nAPI schema defined by the OpenAPI standard decides how the data is sent \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 11}}, {"text": "API schema defined by the OpenAPI standard decides how the data is sent \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 11}}, {"text": "FastAPI \u2013 Python Web Framework \n \n7 \n \nusing JSON Schema.  Visit http://127.0.0.1:8000/openapi.json from your \nbrowser. A neatly formatted JSON response as follows will be displayed: \n{ \n  \"openapi\": \"3.0.2\", \n  \"info\": { \n    \"title\": \"FastAPI\", \n    \"version\": \"0.1.0\" \n  }, \n  \"paths\": { \n    \"/\": { \n      \"get\": { \n        \"summary\": \"Index\", \n        \"operationId\": \"index__get\", \n        \"responses\": { \n          \"200\": { \n            \"description\": \"Successful Response\", \n            \"conte", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 12}}, {"text": "onses\": { \n          \"200\": { \n            \"description\": \"Successful Response\", \n            \"content\": { \n              \"application/json\": { \n                \"schema\": {} \n              } \n            } \n          } \n        } \n      } \n    } \n  } \n} \nFastAPI also supports another automatic documentation method provided \nby Redoc (https://github.com/Redocly/redoc).  ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 12}}, {"text": "FastAPI \u2013 Python Web Framework \n \n8 \n \nEnter http://localhost:8000/redoc as URL in the browser\u2019s address bar. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 13}}, {"text": "FastAPI \u2013 Python Web Framework \n \n9 \n \nUnlike the Flask framework, FastAPI doesn\u2019t contain any built -in \ndevelopment server. Hence we need Uvicorn. It implements ASGI \nstandards and is lightning fast. ASGI stands for Asynchronous Server \nGateway Interface.  \nThe WSGI (Web Server Gateway Interface \u2013 the older standard) compliant \nweb servers are not suitable for asyncio applications. Python web \nframeworks (such as FastAPI) implementing ASGI specifications provide \nhigh speed performance, compar", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 14}}, {"text": "rameworks (such as FastAPI) implementing ASGI specifications provide \nhigh speed performance, comparable to web apps built with Node and Go. \nUvicorn uses uvloop and httptools libraries. It also provides support for \nHTTP/2 and WebSockets, which cannot be handled by WSGI. uvloop id \nsimilar to the built -in asyncio event loop. httptools library handles the \nhttp protocols. \nThe installation of Uvicorn as described ear lier will install it with minimal \ndependencies. However, standard installatio", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 14}}, {"text": "corn as described ear lier will install it with minimal \ndependencies. However, standard installation will also install cython based \ndependencies along with other additional libraries. \npip3 install uvicorn(standard) \nWith this, the WebSockets protocol will be supported. Also, PyYAML will \nbe installed to allow you to provide a .yaml file. \nAs mentioned earlier, the application is launched on the Uvicorn server with \nthe following command: \nuvicorn main:app \u2013reload \nThe --reload option enables ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 14}}, {"text": " Uvicorn server with \nthe following command: \nuvicorn main:app \u2013reload \nThe --reload option enables the debug mode so that any changes in app.py \nwill be automatically reflected and the display on the client browser will be \nautomatically refreshed. In addition, the following command -line options \nmay be used: \n--host TEXT                      Bind socket to this host.  [default 127.0.0.1] \n--port INTEGER                   Bind socket to this port.  [default 8000] \n--uds TEXT                   ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 14}}, {"text": "t INTEGER                   Bind socket to this port.  [default 8000] \n--uds TEXT                       Bind to a UNIX domain socket. \n--fd INTEGER                     Bind to socket from this file descriptor. \n--reload                         Enable auto-reload. \n4. FastAPI \u2013 Uvicorn ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 14}}, {"text": "FastAPI \u2013 Python Web Framework \n \n10 \n \n--reload-dir PATH                Set reload directories explicitly, default \ncurrent working directory. \n--reload-include TEXT            Include files while watching. Includes '*.py' by \ndefault \n-reload-exclude TEXT            Exclude while watching for files.  \n--reload-delay FLOAT             Delay between previous and next check default \n0.25 \n-loop \n[auto|asyncio|uvloop]   Event loop implementation.  [default auto] \n--http \n[auto|h11|httptools]      ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 15}}, {"text": "uto|asyncio|uvloop]   Event loop implementation.  [default auto] \n--http \n[auto|h11|httptools]      HTTP protocol implementation.  [default auto] \n--interface \nauto|asgi|asgi|wsgi  Select application interface.  [default auto] \n--env-file PATH                  Environment configuration file. \n--log-config PATH                Logging configuration file. Supported formats \n.ini, .json, .yaml. \n--version                        Display the uvicorn version and exit. \n--app-dir TEXT                   ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 15}}, {"text": "sion                        Display the uvicorn version and exit. \n--app-dir TEXT                   Look for APP in the specified directory default \ncurrent directory \n--help                           Show this message and exit. \n \nInstead of starting Uvicorn server from command line, it can be launched \nprogrammatically also.  \nExample \nIn the Python code, call uvicorn.run() method, using any of the \nparameters listed above: \nimport uvicorn \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 15}}, {"text": "the \nparameters listed above: \nimport uvicorn \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.get(\"/\") ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 15}}, {"text": "FastAPI \u2013 Python Web Framework \n \n11 \n \nasync def index(): \n    return {\"message\": \"Hello World\"} \n \nif __name__ == \"__main__\": \n    uvicorn.run(\"main:app\", host=\"127.0.0.1\", port=8000, reload=True) \nNow run this app.py as Python script as follows: \n(fastapienv) C:\\fastapienv>python app.py \nUvicorn server will thus be launched in debug mode. \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 16}}, {"text": "FastAPI \u2013 Python Web Framework \n \n12 \n \nFastAPI makes extensive use of the Type hinting feature made available in \nPython\u2019s version 3.5 onwards. As a matter of fact, Python is known to be a \ndynamically typed language. It also happens to be Python\u2019s distinct feature. \nIn a Python code, a variable need not be declared to be belonging to a \ncertain type, and its type is determined dynamically by the instantaneous \nvalue assigned to it. Python\u2019s interpreter doesn\u2019t perform type checks and \nhence it", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 17}}, {"text": " instantaneous \nvalue assigned to it. Python\u2019s interpreter doesn\u2019t perform type checks and \nhence it is prone to runtime exceptions. \nIn the following example, a division() function is defined with two \nparameters and returns their division, assuming that the parameters will be \nnumeric. \n>>> def division(a, b): \n return a/b \n>>> division(10, 4) \n2.5 \n \n>>> division(10, 2.5) \n4.0 \nHowever, if one of the values passed to the function happen to be non -\nnumeric, it results in TypeError as shown be", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 17}}, {"text": "of the values passed to the function happen to be non -\nnumeric, it results in TypeError as shown below: \n>>> division(\"Python\",5) \n \nTypeError: unsupported operand type(s) for /: 'str' and 'int' \nEven a basic coding environment such as IDLE indicates that the function \nrequires two parameters but won\u2019t specify the types as they haven\u2019t been \ndeclared. \n5. FastAPI \u2013 Type Hints ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 17}}, {"text": "FastAPI \u2013 Python Web Framework \n \n13 \n \n \nPython\u2019s new type hinting feature helps in prom pting the user with the \nexpected type of the parameters to be passed. This is done by adding a \ncolon and data type after the parameter. We\u2019ll redefine the division() \nfunction as follows: \n \nNote that while calling the function, Python hints at the expected type of \neach parameter to be passed. However, this doesn\u2019t prevent the TypeError \nfrom appearing if an incompatible value is passed. You will have to", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 18}}, {"text": "s doesn\u2019t prevent the TypeError \nfrom appearing if an incompatible value is passed. You will have to use a \nstatic type checker such as MyPy to check for compatibility before running.  \nJust as the formal parameters in the function\u2019s definition, it is possible to \nprovide type hint for a function\u2019s return value. Just before the colon symbol \nin the function\u2019s definition statement (after which the function block starts) \nadd an arrow (->) and the type. \n \nHowever, as mentioned earlier, if incompa", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 18}}, {"text": "function block starts) \nadd an arrow (->) and the type. \n \nHowever, as mentioned earlier, if incompatible values are passed to the \nfunction, or returned by the function, Python reports TypeError. Use of MyPy \nstatic type checker can detect such errors. Install mypy package first. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 18}}, {"text": "FastAPI \u2013 Python Web Framework \n \n14 \n \npip3 install mypy \nSave the following code as typecheck.py \ndef division(x:int, y:int) -> int: \n return (x//y) \n \na=division(10,2) \nprint (a) \n \nb=division(5,2.5) \nprint (b) \n \nc=division(\"Hello\",10) \nprint (c) \nCheck this code for type errors using mypy. \nC:\\python37>mypy typechk.py \ntypechk.py:7: error: Argument 2 to \"division\" has incompatible \ntype \"float\"; expected \"int\" \ntypechk.py:10: error: Argument 1 to \"division\" has \nincompatible type \"str\"; exp", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 19}}, {"text": "t\"; expected \"int\" \ntypechk.py:10: error: Argument 1 to \"division\" has \nincompatible type \"str\"; expected \"int\" \nFound 2 errors in 1 file (checked 1 source file) \nThere are errors in second and third calls to the function. In second, value \npassed to y is float when int is expected. In third, value passed to x is str \nwhen int is expected. (Note that // operator returns integer division) \nAll standard d ata types can be used as type hints. This can be done with \nglobal variables, variables as fu", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 19}}, {"text": "dard d ata types can be used as type hints. This can be done with \nglobal variables, variables as function parameters, inside function definition \netc. \nx: int = 3 \ny: float = 3.14 ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 19}}, {"text": "FastAPI \u2013 Python Web Framework \n \n15 \n \nnm: str = 'abc' \nmarried: bool = False \nnames: list = ['a', 'b', 'c'] \nmarks: tuple = (10, 20, 30) \nmarklist: dict = {'a': 10, 'b': 20, 'c': 30} \nA new addition in newer versions of Python (version 3.5 onwards) standard \nlibrary is the typing module. It defines special types for corresponding \nstandard collection types. The types on typing module are List, Tuple, \nDict, and Sequence. It also consists of Union and Optional types. Note \nthat standard names o", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 20}}, {"text": "uple, \nDict, and Sequence. It also consists of Union and Optional types. Note \nthat standard names of data types are all in small case, whereas ones in \ntyping module have first letter in upper case. Using this feature, we can ask \na collection of a particular type. \nfrom typing import List, Tuple, Dict \n \n# following line declares a List object of strings.  \n# If violated, mypy shows error \ncities: List[str] = ['Mumbai', 'Delhi', 'Chennai'] \n \n# This is Tuple with three elements respectively  \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 20}}, {"text": "s: List[str] = ['Mumbai', 'Delhi', 'Chennai'] \n \n# This is Tuple with three elements respectively  \n# of str, int and float type) \nemployee: Tuple[str, int, float] = ('Ravi', 25, 35000) \n \n# Similarly in the following Dict, the object key should be str \n# and value should be of int type, failing which  \n# static type checker throws error \nmarklist: Dict[str, int] = {'Ravi': 61, 'Anil': 72} ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 20}}, {"text": "FastAPI \u2013 Python Web Framework \n \n16 \n \nThe Type Hinting feature of Python is most effectively used in almost all \nIDEs (Integrated Development Environments) such as PyCharm and VS \nCode to provide dynamic autocomplete features. \nLet us see how VS Code  uses the type hints to provide autocomplete \nsuggestions while writing a code. In the example below, a function named \nas sayhello with name as an argument has been defined. The function \nreturns a string by concatenating \u201cHello\u201d to the name para", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 21}}, {"text": " argument has been defined. The function \nreturns a string by concatenating \u201cHello\u201d to the name parameter by adding \na space in between. Additionally, it is required to ensure that the first letter \nof the name be in upper case.  \nPython\u2019s str class has a capitalize() method for the purpose, but if one \ndoesn\u2019t remember it while typing the code, one has to search for it  \nelsewhere. If you give a dot after name, you expect the list of attributes but \nnothing is shown because Python doesn\u2019t know ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 21}}, {"text": "dot after name, you expect the list of attributes but \nnothing is shown because Python doesn\u2019t know what will be the runtime \ntype of name variable. \n \nHere, type hint comes handy. Include str as the type of name in the \nfunction definition. Now when you press dot (.) after name, a drop down \nlist of all string methods appears, from which the required method (in this \ncase capitalize()) can be picked. \n6. FastAPI \u2013 IDE Support ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 21}}, {"text": "ked. \n6. FastAPI \u2013 IDE Support ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 21}}, {"text": "FastAPI \u2013 Python Web Framework \n \n17 \n \n \nIt is also possible to use type hints with a user defined class. In the following \nexample a rectangle class is defined with type hints for arguments to the  \n__init__() constructor. \nclass rectangle: \n    def __init__(self, w:int, h:int) ->None: \n        self.width=w \n        self.height=h \nFollowing is a function that uses an object of above rec tangle class as an \nargument. The type hint used in the declaration is the name of the class. \ndef area(r:re", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 22}}, {"text": "lass as an \nargument. The type hint used in the declaration is the name of the class. \ndef area(r:rectangle)->int: \n    return r.width*r.height \n \nr1=rectangle(10,20) \nprint (\"area = \", area(r1)) \nIn this case also, the IDE editor provides autocomplete su pport prompting \nlist of the instance attributes. Following is a screenshot of PyCharm editor.  \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 22}}, {"text": "FastAPI \u2013 Python Web Framework \n \n18 \n \n \nFastAPI makes extensive use of the type hints. This feature is found \neverywhere, such as path parameters, query parameters, headers, bodies, \ndependencies, etc. as well as validating the data from the incoming request. \nThe OpenAPI document generation also uses type hints. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 23}}, {"text": "FastAPI \u2013 Python Web Framework \n \n19 \n \nRElational State Transfer (REST) is a software architectural style. REST \ndefines how the architecture of a web application should behave. It is a \nresource based architecture where everything that the REST server hosts, \n(a file, an image, or a row in a table of a database), is a resource , having \nmany representations.  \nREST recommends certain architectural constraints. \n\uf0b7 Uniform interface \n \n\uf0b7 Statelessness \n \n\uf0b7 Client-server \n \n\uf0b7 Cacheability \n \n\uf0b7 La", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 24}}, {"text": "al constraints. \n\uf0b7 Uniform interface \n \n\uf0b7 Statelessness \n \n\uf0b7 Client-server \n \n\uf0b7 Cacheability \n \n\uf0b7 Layered system \n \n\uf0b7 Code on demand \nREST constraints has the following advantages: \n\uf0b7 Scalability \n \n\uf0b7 Simplicity \n \n\uf0b7 Modifiability \n \n\uf0b7 Reliability \n \n\uf0b7 Portability \n \n\uf0b7 Visibility \n \nREST uses HTTP verbs or methods for the operation on the resources. The \nPOST, GET, PUT and DELETE methods perform respectively CREATE, READ, \nUPDATE and DELETE operations respectively. \n7. FastAPI \u2013 REST Architectur", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 24}}, {"text": "espectively CREATE, READ, \nUPDATE and DELETE operations respectively. \n7. FastAPI \u2013 REST Architecture ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 24}}, {"text": "FastAPI \u2013 Python Web Framework \n \n20 \n \nModern web frameworks use routes or endpoints as a part of URL instead \nof file-based URLs. This helps the user to remember the application URLs \nmore effectively. In FastAPI, it is termed a path. A path or route is the part \nof the URL trailing after the first \u2018/\u2019.  \nFor example, in the following URL,  \nhttp://localhost:8000/hello/TutorialsPoint \nthe path or the route would be \n/hello/TutorialsPoint \nIn FastAPI, such a path string is given as a parameter ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 25}}, {"text": "r the route would be \n/hello/TutorialsPoint \nIn FastAPI, such a path string is given as a parameter to the operation \ndecorator. The operation here refers to the HTTP verb used by the browser \nto send the data. These operations include GET, PUT, etc. The operation \ndecorator (for example, @app.get(\"/\")) is immediately followed by a \nfunction that is executed when the specified URL is visited. In the below \nexample: \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.get(\"/\") \nasync def index()", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 25}}, {"text": "he below \nexample: \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.get(\"/\") \nasync def index(): \n    return {\"message\": \"Hello World\"} \nHere, (\"/\") is the path,  get is the operation, @app.get(\"/\") is the path \noperation decorator, and the index() function just below it is termed as \npath operation function. \nAny of the following HTTP verbs can be used as operations. \nGET Sends data in unencrypted form to the server. Most \ncommon method. \nHEAD Same as GET, but without the response body. \n8", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 25}}, {"text": "rypted form to the server. Most \ncommon method. \nHEAD Same as GET, but without the response body. \n8. FastAPI \u2013 Path Parameters ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 25}}, {"text": "FastAPI \u2013 Python Web Framework \n \n21 \n \nPOST Used to send HTML form data to the server. Data received \nby the POST method is not cached by the server. \nPUT Replaces all current representations of the target resource \nwith the uploaded content. \nDELETE Removes all current representations of the target resource \ngiven by a URL. \n \nThe async keyword in the function\u2019s definition tells FastAPI that it is to be \nrun asynchronously i.e. without blocking the current thread of execution. \nHowever, a path", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 26}}, {"text": "is to be \nrun asynchronously i.e. without blocking the current thread of execution. \nHowever, a path operation function can be defined without the async prefix \nalso. \nThis decorated function returns a JSON response. Although it can return \nalmost any of Python\u2019s objects, it will be automatically converted to JSON. \nFurther in this tutorial, we shall see how such a function returns Pydantic \nmodel objects. \nThe URL\u2019s endpoint or path can have one or more variable parameters. They \ncan be accepte", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 26}}, {"text": " objects. \nThe URL\u2019s endpoint or path can have one or more variable parameters. They \ncan be accepted by using Python\u2019s string formatting notation. In the above \nexample URL http://localhost:8000/hello/TutorialsPoint,  the last value may \nchange in every client request. This variable parameter can be accepted in \na variable as defined in the path and passed to the formal parameters \ndefined in the function bound to the operation decorator. \nExample \nAdd another path decorator with a variable par", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 26}}, {"text": " function bound to the operation decorator. \nExample \nAdd another path decorator with a variable parameter in the route, and bind \nhello() function to have name parameter. Modify the main.py as per the \nfollowing. \nimport uvicorn \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.get(\"/\") \nasync def index(): \n    return {\"message\": \"Hello World\"} \n \n@app.get(\"/hello/{name}\") ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 26}}, {"text": "FastAPI \u2013 Python Web Framework \n \n22 \n \nasync def hello(name): \n    return {\"name\": name} \nStart the Uvicorn server and visit http://localhost:8000/hello/Tutorialspoint \nURL. The browser shows the following JSON response. \n{\"name\":\"Tutorialspoint\"} \nChange the variable path parameter to something else such as \nhttp://localhost:8000/hello/Python so that the browser shows: \n{\"name\":\"Python\"} \nCheck OpenAPI docs \nNow if we c heck the OpenAPI documentation by entering the URL as \nhttp://localhost:80", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 27}}, {"text": "OpenAPI docs \nNow if we c heck the OpenAPI documentation by entering the URL as \nhttp://localhost:8000/docs, it will show two routes and their respective view \nfunctions. Click the try out button below /hello/{name} button and give \nTutorialspoint as the value of the name parameter\u2019s description and then \nclick the Execute button. ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 27}}, {"text": "FastAPI \u2013 Python Web Framework \n \n23 \n \n \nIt will then show the Curl command, the request URL and the details of \nserver\u2019s response with response body and response headers. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 28}}, {"text": "FastAPI \u2013 Python Web Framework \n \n24 \n \n \nA route can have multiple parameters separated by \"/\" symbol.  \nfrom fastapi import FastAPI \napp = FastAPI() \n@app.get(\"/hello/{name}/{age}\") \nasync def hello(name,age): \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 29}}, {"text": "FastAPI \u2013 Python Web Framework \n \n25 \n \n    return {\"name\": name, \"age\":age} \nIn this case, /hello is the route, followed by two parameters put in curly \nbrackets. If the URL given in the browser\u2019s address bar is \nhttp://localhost:8000/hello/Ravi/20, The data of Ravi and 20 will be \nassigned to variables name and age respectively. The browser displays the \nfollowing JSON response: \n{\"name\":\"Ravi\",\"age\":\"20\"} \nPath Parameters with T ypes \nYou can use Python\u2019s type hints for the parameters of the ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 30}}, {"text": "\"age\":\"20\"} \nPath Parameters with T ypes \nYou can use Python\u2019s type hints for the parameters of the function to be \ndecorated. In this case, define name as str and age as int. \n@app.get(\"/hello/{name}/{age}\") \nasync def hello(name:str,age:int): \n    return {\"name\": name, \"age\":age}  \nThis will result in the browser displaying an HTTP error message in the JSON \nresponse if the types don\u2019t match. Try entering \nhttp://localhost:8000/hello/20/Ravi as the URL. The browser\u2019s response will \nbe as follo", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 30}}, {"text": "y entering \nhttp://localhost:8000/hello/20/Ravi as the URL. The browser\u2019s response will \nbe as follows: \n{ \n  \"detail\": [ \n    { \n      \"loc\": [ \n        \"path\", \n        \"age\" \n      ], \n      \"msg\": \"value is not a valid integer\", \n      \"type\": \"type_error.integer\" \n    } \n  ] ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 30}}, {"text": "FastAPI \u2013 Python Web Framework \n \n26 \n \n} \nThe reason is obvious as age being integer, can\u2019t accept a string value. This \nwill also be reflected in the Swagger UI (OpenAPI) documentation. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 31}}, {"text": "FastAPI \u2013 Python Web Framework \n \n27 \n \nA classical method of passing the request data to the server is to append a \nquery string to the URL. Assuming that a Python script (hello.py) on a server \nis executed as CGI, a list of key-value pairs concatenated by the \nampersand (&) forms the query string , which is appended to the URL by \nputting a question mark (?) as a separator. For example: \nhttp://localhost/cgi-bin/hello.py?name=Ravi&age=20  \nThe trailing part of the URL, after (?), is th e query", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 32}}, {"text": "localhost/cgi-bin/hello.py?name=Ravi&age=20  \nThe trailing part of the URL, after (?), is th e query string, which is then \nparsed by the server-side script for further processing. \nAs mentioned, the query string is a list of parameter=value pairs \nconcatenated by & symbol. FastAPI automatically treats the part of the \nendpoint which is not a path parameter as a query string and parses it into \nparameters and its values. These parameters are passed to the function \nbelow the operation decorator.", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 32}}, {"text": "rameters and its values. These parameters are passed to the function \nbelow the operation decorator. \nExample \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.get(\"/hello\") \nasync def hello(name:str,age:int): \n    return {\"name\": name, \"age\":age} \nStart the Uvicorn server and this URL in the browser: \nhttp://localhost:8000/hello?name=Ravi&age=20 \nYou should get the same JSON response. However, checking the t ells you \nthat FastAPI has detected that /hello endpoint has no path parameters, bu", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 32}}, {"text": ", checking the t ells you \nthat FastAPI has detected that /hello endpoint has no path parameters, but \nquery parameters.  \n9. FastAPI \u2013 Query Parameters ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 32}}, {"text": "FastAPI \u2013 Python Web Framework \n \n28 \n \n \nClick the Try it out button, enter \"Ravi\" and \"20\" as values, and press the \nExecute button. The documentation page now shows Curl command, \nrequest URL, and the body and headers of HTTP response. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 33}}, {"text": "FastAPI \u2013 Python Web Framework \n \n29 \n \n \nExample \nYou can use Python\u2019s type hints for the parameters of the function to be \ndecorated. In this case, define name as str and age as int. \nfrom fastapi import FastAPI \napp = FastAPI() \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 34}}, {"text": "FastAPI \u2013 Python Web Framework \n \n30 \n \n@app.get(\"/hello/{name}\") \nasync def hello(name:str,age:int): \n    return {\"name\": name, \"age\":age} \nTry entering http://localhost:8000/docs as the URL. This will open the \nSwagger UI (OpenAPI) documentation. The parameter 'name' is a path \nparameter and 'age' is a query parameter. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 35}}, {"text": "FastAPI \u2013 Python Web Framework \n \n31 \n \nIt is possible to apply validation conditions on path parameters as well \nas query parameters of the URL. In order to apply the validation conditions \non a path parameter, you need to import the Path class. In addition to the \ndefault value of the parameter, you can specify the maximum and minimum \nlength in the case of a string parameter. \nfrom fastapi import FastAPI, Path \napp = FastAPI() \n \n@app.get(\"/hello/{name}\") \nasync def hello(name:str=Path(...,mi", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 36}}, {"text": "rt FastAPI, Path \napp = FastAPI() \n \n@app.get(\"/hello/{name}\") \nasync def hello(name:str=Path(...,min_length=3, \nmax_length=10)): \n    return {\"name\": name} \nIf the browser\u2019s URL contains the parameter with a length less than 3 or \nmore than 10, as in ( http://localhost:8000/hello/Tutorialspoint), there will \nbe an appropriate error message such as: \n{ \n  \"detail\": [ \n    { \n      \"loc\": [ \n        \"path\", \n        \"name\" \n      ], \n      \"msg\": \"ensure this value has at most 10 characters\", \n  ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 36}}, {"text": "  \"path\", \n        \"name\" \n      ], \n      \"msg\": \"ensure this value has at most 10 characters\", \n      \"type\": \"value_error.any_str.max_length\", \n      \"ctx\": { \n        \"limit_value\": 10 \n      } \n10. FastAPI \u2013 Parameter Validation ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 36}}, {"text": "FastAPI \u2013 Python Web Framework \n \n32 \n \n    } \n  ] \n} \nThe OpenAPI docs also shows the validations applied: \n \nValidation rules can be applied on numeric parameters too, using the \noperators as given below: \n\uf0b7 gt: greater than \n\uf0b7 ge: greater than or equal \n\uf0b7 lt: less than \n\uf0b7 le: less than or equal \nLet us modify the  above operation decorator to include age as a path \nparameter and apply the validations. \nfrom fastapi import FastAPI, Path \napp = FastAPI() \n@app.get(\"/hello/{name}/{age}\") \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 37}}, {"text": "ations. \nfrom fastapi import FastAPI, Path \napp = FastAPI() \n@app.get(\"/hello/{name}/{age}\") \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 37}}, {"text": "FastAPI \u2013 Python Web Framework \n \n33 \n \nasync def hello(*, name: str=Path(...,min_length=3 , \nmax_length=10), age: int = Path(..., ge=1, le=100)): \n    return {\"name\": name, \"age\":age} \nIn this case, validation rules are applied for both the parameters name and \nage. If the URL entered is http://localhost:8000/hello/hi/110, then the  \nJSON response shows following explanations for validation failure: \n{ \n  \"detail\": [ \n    { \n      \"loc\": [ \n        \"path\", \n        \"name\" \n      ], \n      \"msg\"", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 38}}, {"text": "re: \n{ \n  \"detail\": [ \n    { \n      \"loc\": [ \n        \"path\", \n        \"name\" \n      ], \n      \"msg\": \"ensure this value has at least 3 characters\", \n      \"type\": \"value_error.any_str.min_length\", \n      \"ctx\": { \n        \"limit_value\": 3 \n      } \n    }, \n    { \n      \"loc\": [ \n        \"path\", \n        \"age\" \n      ], \n      \"msg\": \"ensure this value is less than or equal to 100\", \n      \"type\": \"value_error.number.not_le\", \n      \"ctx\": { \n        \"limit_value\": 100 \n      } ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 38}}, {"text": " \"value_error.number.not_le\", \n      \"ctx\": { \n        \"limit_value\": 100 \n      } ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 38}}, {"text": "FastAPI \u2013 Python Web Framework \n \n34 \n \n    } \n  ] \n} \nThe swagger UI documentation also identifies the constraints. \n \nThe query parameters can also have the validation rules applied to them. \nYou have to specify them as the part of arguments of Query class \nconstructor. \nLet us add a q uery parameter called percent in the above function and \napply the validation rules as ge=0 (i.e., greater then equal to 0) and \nlt=100 (less than or equal to 100) \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 39}}, {"text": " equal to 0) and \nlt=100 (less than or equal to 100) \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 39}}, {"text": "FastAPI \u2013 Python Web Framework \n \n35 \n \nfrom fastapi import FastAPI, Path, Query \n \n@app.get(\"/hello/{name}/{age}\") \nasync def hello(*, name: str=Path(...,min_length=3 , \nmax_length=10), \\ \n                age: int = Path(..., ge=1, le=100), \\ \n                percent:float=Query(..., ge=0, le=100)): \n    return {\"name\": name, \"age\":age} \nIf the URL entered is http://localhost:8000/hello/Ravi/20?percent=79, then \nthe browser displays following JSON response: \n{\"name\":\"Ravi\",\"age\":20} \nFastAPI co", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 40}}, {"text": "ercent=79, then \nthe browser displays following JSON response: \n{\"name\":\"Ravi\",\"age\":20} \nFastAPI correctly identifies percent as a query parameter with validati on \nconditions applied. It is reflected in the OpenAPI documentation as follows: ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 40}}, {"text": "FastAPI \u2013 Python Web Framework \n \n36 \n \n \nWhile the client can send the path and query parameters to the API server \nusing GET method, we need to apply POST method to send some binary \ndata as a part of the HTTP request. This binary data may be in the form of \nan object of any Python class. It forms the request body. FastAPI uses \nPydantic library for this purpose. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 41}}, {"text": "FastAPI \u2013 Python Web Framework \n \n37 \n \nPydantic is a Python library for data parsing and validation. It uses the \ntype hinting me chanism of the newer versions of Python (version 3.6 \nonwards) and validates the types during the runtime. Pydantic defines \nBaseModel class. It acts as the base class for creating user defined models. \nFollowing code defines a Student class as a model based on BaseModel. \nfrom typing import List \nfrom pydantic import BaseModel \n \nclass Student(BaseModel): \n    id: i", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 42}}, {"text": "el. \nfrom typing import List \nfrom pydantic import BaseModel \n \nclass Student(BaseModel): \n    id: int \n    name :str \n    subjects: List[str] = [] \nThe attributes of the Student class are declared with type hints. Note that \nthe subjects attribute is of List type defined in typing module and of built -\nin list type. \nWe can populate an object of Student class with a dictionary with matching \nstructure as follows: \n>>> data = { \n    'id': 1, \n    'name': 'Ravikumar', \n    'subjects': [\"Eng\", \"Ma", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 42}}, {"text": "cture as follows: \n>>> data = { \n    'id': 1, \n    'name': 'Ravikumar', \n    'subjects': [\"Eng\", \"Maths\", \"Sci\"], \n} \n>>> s1=Student(**data) \n>>> print (s1) \nid=1 name='Ravikumar' subjects=['Eng', 'Maths', 'Sci'] \n>>> s1 \nStudent(id=1, name='Ravikumar', subjects=['Eng', 'Maths', 'Sci']) \n11. FastAPI \u2013 Pydantic ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 42}}, {"text": "FastAPI \u2013 Python Web Framework \n \n38 \n \n>>> s1.dict() \n{'id': 1, 'name': 'Ravikumar', 'subjects': ['Eng', 'Maths', 'Sci']} \nPydantic will automatically get the data types converted whenever \npossible. For example, even if the id key in the dictionary is assigned a \nstring representation of a number (such as '123'), it will coerce it into an \ninteger. But whenever not possible, an exception will be raised. \n>>> data = { \n    'id': [1,2], \n    'name': 'Ravikumar', \n    'subjects': [\"Eng\", \"Maths\",", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 43}}, {"text": " raised. \n>>> data = { \n    'id': [1,2], \n    'name': 'Ravikumar', \n    'subjects': [\"Eng\", \"Maths\", \"Sci\"], \n} \n>>> s1=Student(**data) \nTraceback (most recent call last): \n  File \"<pyshell#13>\", line 1, in <module> \n    s1=Student(**data) \n  File \"pydantic\\main.py\", line 406, in \npydantic.main.BaseModel.__init__ \npydantic.error_wrappers.ValidationError: 1 validation error \nfor Student \nid \n  value is not a valid integer (type=type_error.integer) \nPydantic also contains a Field class to declare ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 43}}, {"text": "e is not a valid integer (type=type_error.integer) \nPydantic also contains a Field class to declare metadata and validation rules \nfor the model attributes. First modify the Student class to apply Field type \non \"name\" attribute as follows: \nfrom typing import List \nfrom pydantic import BaseModel, Field \n \nclass Student(BaseModel): \n    id: int \n    name :str = Field(None, title=\"The description of the \nitem\", max_length=10) ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 43}}, {"text": "f the \nitem\", max_length=10) ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 43}}, {"text": "FastAPI \u2013 Python Web Framework \n \n39 \n \n    subjects: List[str] = [] \nPopulate the data as shown below. The name here is exceeding the \nmax_length stipulated. Pydantic throws ValidationError as expected. \n>>> data = { \n    'id': 1, \n    'name': 'Ravikumar Sharma', \n    'subjects': [\"Eng\", \"Maths\", \"Sci\"], \n} \n>>> s1=Student(**data) \nTraceback (most recent call last): \n  File \"<pyshell#28>\", line 1, in <module> \n    s1=Student(**data) \n  File \"pydantic\\main.py\", line 406, in \npydantic.main.BaseMo", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 44}}, {"text": ", in <module> \n    s1=Student(**data) \n  File \"pydantic\\main.py\", line 406, in \npydantic.main.BaseModel.__init__ \npydantic.error_wrappers.ValidationError: 1 validation error \nfor Student \nname \n  ensure this value has at most 10 characters \n(type=value_error.any_str.max_length; limit_value=10) \nPydantic models can be used to map with ORM models like SQLAlchemy \nor Peewee. ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 44}}, {"text": "FastAPI \u2013 Python Web Framework \n \n40 \n \nWe shall now use the Pydantic model object as a request body of the client\u2019s \nrequest. As mentioned earlier, we need to use POST operation decorator for \nthe purpose. \nimport uvicorn \nfrom fastapi import FastAPI \nfrom typing import List \nfrom pydantic import BaseModel, Field \napp = FastAPI() \nclass Student(BaseModel): \n    id: int \n    name :str = Field(None, title=\"name of student\", max_length=10) \n    subjects: List[str] = [] \n \n@app.post(\"/students/\") \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 45}}, {"text": ", title=\"name of student\", max_length=10) \n    subjects: List[str] = [] \n \n@app.post(\"/students/\") \nasync def student_data(s1: Student): \n    return s1 \nAs it can be seen, the student_data() function is decorated by \n@app.post() decorator having the URL endpoint as \"/students/\". It \nreceives an object of Student class as Body parameter from the client\u2019s \nrequest. To test this route, start the Uvicorn server and open the Swagger \nUI documentation in the browser by visiting http://localhost:8000/d", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 45}}, {"text": "orn server and open the Swagger \nUI documentation in the browser by visiting http://localhost:8000/docs \nThe documentation identifies that \"/students/\" route is attached with \nstudent_data() function with POST method.  Under the schemas section \nthe Student model will be listed.  \n12. FastAPI \u2013 Request Body ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 45}}, {"text": "FastAPI \u2013 Python Web Framework \n \n41 \n \n \nExpand the node in front of it to reveal the structure of the model \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 46}}, {"text": "FastAPI \u2013 Python Web Framework \n \n42 \n \n \nClick the Try it out button to fill in the test values in the request body. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 47}}, {"text": "FastAPI \u2013 Python Web Framework \n \n43 \n \n \nClick the Execute button and get the server\u2019s response values. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 48}}, {"text": "FastAPI \u2013 Python Web Framework \n \n44 \n \n \nWhile a Pydantic model automatically populates the request body, it is also \npossible to use singular values to add attributes to it. For that purpose, we \nneed to use Body class objects as the parameters of the operation function \nto be decorated. \nFirst, we need to import Body class from fastapi. As shown in the following \nexample, declare ' name' and 'marks' as the Body parameters in the \ndefinition of student_data() function below the @app.post() dec", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 49}}, {"text": "arks' as the Body parameters in the \ndefinition of student_data() function below the @app.post() decorator. \nimport uvicorn \nfrom fastapi import FastAPI, Body \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 49}}, {"text": "FastAPI \u2013 Python Web Framework \n \n45 \n \n \n@app.post(\"/students\") \nasync def student_data(name:str=Body(...), \nmarks:int=Body(...)): \n    return {\"name\":name,\"marks\": marks} \nIf we check the Swagger UI documentation, we should be able to find this \nPOST method associated to student_data() function and having a request \nbody with two parameters. \n \nIt is also possible to declare an operation function to have path and/or query \nparameters along with request body. Let us modify the student_data() \nf", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 50}}, {"text": "n to have path and/or query \nparameters along with request body. Let us modify the student_data() \nfunction to have a path parameter 'college\u2019, 'age' as query parameter and \na Student model object as body parameter. \n@app.post(\"/students/{college}\") \nasync def student_data(college:str, age:int, student:Student): \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 50}}, {"text": "FastAPI \u2013 Python Web Framework \n \n46 \n \n    retval={\"college\":college, \"age\":age, **student.dict()} \n    return retval \nThe function adds values of college and age parameters along with the \ndictionary representation of Student object and returns it as a response. We \ncan check the API documentation as follows: \n \nAs it can be seen, college is the path parameter, age is a query parameter, \nand the Student model is the request body. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 51}}, {"text": " Student model is the request body. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 51}}, {"text": "FastAPI \u2013 Python Web Framework \n \n47 \n \nBy default, FastAPI renders a JSON response to the client. However, it can \nbe cast to a HTML response. For this purpose, FastAPI has HTMLResponse \nclass defined in fastapi.responses module. We need to add \nresponse_class as an additional parameter to operation decorator, with \nHTMLResponse object as its value. \nIn the following example, the @app.get() decorator has \"/hello/\" endpoint \nand the HTMLRespo nse as response_class. Inside the hello() function, w", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 52}}, {"text": "ator has \"/hello/\" endpoint \nand the HTMLRespo nse as response_class. Inside the hello() function, we \nhave a string representation of a HTML code of Hello World message. The \nstring is returned in the form of HTML response. \nfrom fastapi.responses import HTMLResponse \nfrom fastapi import FastAPI \napp = FastAPI() \n@app.get(\"/hello/\") \nasync def hello(): \n    ret=''' \n<html> \n<body> \n<h2>Hello World!</h2> \n</body> \n</html> \n''' \n    return HTMLResponse(content=ret) \nOn examining the API docs, it ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 52}}, {"text": "d!</h2> \n</body> \n</html> \n''' \n    return HTMLResponse(content=ret) \nOn examining the API docs, it can be seen that the server\u2019s response body \nis in HTML. \n13. FastAPI \u2013 Templates ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 52}}, {"text": "FastAPI \u2013 Python Web Framework \n \n48 \n \n \nThe request URL ( http://localhost:8000/hello/) should also render the \nmessage in the browser. However, rendering a raw HTML response is very \ntedious. Alternately, it is possible to render prebuilt HTML pages as \ntemplates. For that we need to use a web template library. \nWeb template library has a template engine that merges a static web page \nhaving place holder variables. Data from any source such as database  is \nmerged to dynamically generate and ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 53}}, {"text": "ace holder variables. Data from any source such as database  is \nmerged to dynamically generate and render the web page. FastAPI doesn\u2019t \nhave any prepackaged template library. So one is free to use any one that \nsuits his needs. In this tutorial, we shall be using jinja2, a very popular \nweb template library. Let us install it first using pip installer. \npip3 install jinja2 \nFastAPI\u2019s suppor t for Jinja templates comes in the form of \njinja2Templates class defined in fastapi.templates module. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 53}}, {"text": "r Jinja templates comes in the form of \njinja2Templates class defined in fastapi.templates module. \nfrom fastapi.templating import Jinja2Templates \nTo declare a template object, the folder in which the html templates are \nstored, should be provided as para meter. Inside the current working \ndirectory, we shall create a \u2018templates\u2019 directory. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 53}}, {"text": "FastAPI \u2013 Python Web Framework \n \n49 \n \n \ntemplates = Jinja2Templates(directory=\"templates\") \nA simple web page \u2018hello.html\u2019 to render Hello World message is also put \nin \u2018templates\u2019 folder. \n<html> \n<body> \n<h2>Hello World!</h2> \n</body> \n</html> \nWe are now going to render html code from this page as HTMLResponse. \nLet us modify the hello() function as follows: \nfrom fastapi.responses import HTMLResponse \nfrom fastapi.templating import Jinja2Templates \nfrom fastapi import FastAPI, Request \napp", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 54}}, {"text": "LResponse \nfrom fastapi.templating import Jinja2Templates \nfrom fastapi import FastAPI, Request \napp = FastAPI() \ntemplates = Jinja2Templates(directory=\"templates\") \n \n@app.get(\"/hello/\", response_class=HTMLResponse) \nasync def hello(request: Request): \n    return templates.TemplateResponse(\"hello.html\", \n{\"request\": request}) \nHere, templateResponse() method of template object collects the \ntemplate code and the request context to render the http response. When \nwe start the server and visit th", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 54}}, {"text": "ate code and the request context to render the http response. When \nwe start the server and visit the http://localhost:8000/hello/ URL, we get \nto see the Hello World message in the browser, which is in fact the output \nof hello.html ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 54}}, {"text": "FastAPI \u2013 Python Web Framework \n \n50 \n \n \nAs mentioned earlier, jinja2 template allows certain place holders to be \nembedded in the HTML code. The jinja2 code elements are put inside the \ncurly brackets. As soon as the HTML parser of the browser encounters this, \nthe template engine takes over and populates these code elements by the \nvariable data provided by the HTTP response. Jinja2 provides following code \nelements: \n\uf0b7 {% %} \u2013 Statements \n\uf0b7 {{ }} \u2013 Expressions to print to the template output", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 55}}, {"text": "llowing code \nelements: \n\uf0b7 {% %} \u2013 Statements \n\uf0b7 {{ }} \u2013 Expressions to print to the template output \n\uf0b7 {# #} \u2013 Comments which are not included in the template output \n\uf0b7 # # # \u2013 Line statements \nThe hello.html is modified as below to display a dynamic message by \nsubstituting the name parameter. \n<html> \n<body> \n<h2>Hello {{name}} Welcome to FastAPI</h2> \n</body> \n</html> \nThe operation function hello() is also modified to accept name as a path \nparameter. The TemplateResponse should also includ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 55}}, {"text": "ello() is also modified to accept name as a path \nparameter. The TemplateResponse should also include the JSON \nrepresentation of \u201cname\u201d:name along with the request context. \nfrom fastapi.responses import HTMLResponse \nfrom fastapi.templating import Jinja2Templates \nfrom fastapi import FastAPI, Request \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 55}}, {"text": "FastAPI \u2013 Python Web Framework \n \n51 \n \napp = FastAPI() \ntemplates = Jinja2Templates(directory=\"templates\") \n \n@app.get(\"/hello/{name}\", response_class=HTMLResponse) \nasync def hello(request: Request, name:str): \n    return templates.TemplateResponse(\"hello.html\", \n{\"request\": request, \"name\":name}) \nRestart the server and go to http://localhost:8000/hello/Kiran. The browser \nnow fills the jinja2 place holder with the path parameter in this URL. \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 56}}, {"text": "place holder with the path parameter in this URL. \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 56}}, {"text": "FastAPI \u2013 Python Web Framework \n \n52 \n \nOften it is required to include in the template response some resources that \nremain unchanged even if there is a certain dynamic data. Such resources \nare called static assets. Media files (.png, .jpg etc), JavaScript files to be \nused for executing some front end code, or stylesheets for formatting HTML \n(.CSS files) are the examples of static files. \nIn order to handle static files, you need a library called aiofiles \npip3 install aiofiles \nNext, import", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 57}}, {"text": "rder to handle static files, you need a library called aiofiles \npip3 install aiofiles \nNext, import StaticFiles class from the fastapi.staticfiles module. Its \nobject is one of the parameters for the mount() method of the FastAPI \napplication object to assign \"static\" subfolder in the current application \nfolder to store and serve all the static assets of the application. \napp.mount(app.mount(\"/static\", \nStaticFiles(directory=\"static\"), name=\"static\") \nExample \nIn the following example, FastAPI", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 57}}, {"text": "tatic\", \nStaticFiles(directory=\"static\"), name=\"static\") \nExample \nIn the following example, FastAPI logo is to be rendered in the hello.html \ntemplate. Hence, \u201cfa-logo.png\u201d file is first placed in static folder. It is now \navailable for using as src attribute of <img> tag in HTML code. \nfrom fastapi import FastAPI,  Request \nfrom fastapi.responses import HTMLResponse \nfrom fastapi.templating import Jinja2Templates \nfrom fastapi.staticfiles import StaticFiles \n \napp = FastAPI() \n \ntemplates = Ji", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 57}}, {"text": "rt Jinja2Templates \nfrom fastapi.staticfiles import StaticFiles \n \napp = FastAPI() \n \ntemplates = Jinja2Templates(directory=\"templates\") \n \napp.mount(\"/static\", StaticFiles(directory=\"static\"), \nname=\"static\") \n14. FastAPI \u2013 Static Files ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 57}}, {"text": "FastAPI \u2013 Python Web Framework \n \n53 \n \n     \n@app.get(\"/hello/{name}\", response_class=HTMLResponse) \nasync def hello(request: Request, name:str): \n    return templates.TemplateResponse(\"hello.html\", \n{\"request\": request, \"name\":name}) \nThe HTML code of \\templates\\hello.html is as follows: \n<html> \n<body> \n<h2>Hello {{name}} Welcome to FastAPI</h2> \n<img src=\"{{ url_for('static', path='fa-logo.png') }}\" alt=\"\" \nwidth=\"300\"> \n</body> \n</html> \nRun the Uvicorn server and visit the URL as http://lo", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 58}}, {"text": "') }}\" alt=\"\" \nwidth=\"300\"> \n</body> \n</html> \nRun the Uvicorn server and visit the URL as http://localhost/hello/Vijay. The \nLogo appears in the browser window as shown. \n \n \nExample \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 58}}, {"text": "FastAPI \u2013 Python Web Framework \n \n54 \n \nHere is another example of a static file. A JavaScript code hello.js contains \na definition of myfunction() to be executed on the onload event in \nfollowing HTML script (\\templates\\hello.html) \n<html> \n   <head> \n <title>My Website</title> \n <script src=\"{{ url_for('static', path='hello.js') }}\"></script> \n   </head> \n   <body onload=\"myFunction()\"> \n <div id=\"time\" style=\"text-align:right; width=\"100%\"></div> \n <h1><div id=\"ttl\">{{ name }}</div></h1> \n   ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 59}}, {"text": "d=\"time\" style=\"text-align:right; width=\"100%\"></div> \n <h1><div id=\"ttl\">{{ name }}</div></h1> \n   </body> \n</html> \nThe hello.js code is as follows: (\\static\\hello.js) \nfunction myFunction() { \n  var today = new Date(); \n  var h = today.getHours(); \n  var m = today.getMinutes(); \n  var s = today.getSeconds(); \n  var msg=\"\"; \n  if (h<12) \n  { \n   msg=\"Good Morning, \"; \n  } \n  if (h>=12 && h<18) \n  { \n   msg=\"Good Afternoon, \"; \n  } \n   if (h>=18) \n  { ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 59}}, {"text": "  { \n   msg=\"Good Afternoon, \"; \n  } \n   if (h>=18) \n  { ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 59}}, {"text": "FastAPI \u2013 Python Web Framework \n \n55 \n \n   msg=\"Good Evening, \"; \n  } \n  \nvar x=document.getElementById('ttl').innerHTML; \n  document.getElementById('ttl').innerHTML =  msg+x; \n  document.getElementById('time').innerHTML =  h + \":\" + m + \n\":\" + s; \n} \nThe function detects the value of current time and assigns appropriate value \nto msg variable (good morning, good afternoon or good evening) \ndepending on the time of the day. \nSave /static/hello.js, modify \\templates\\hello.html and restart the \nse", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 60}}, {"text": "ing on the time of the day. \nSave /static/hello.js, modify \\templates\\hello.html and restart the \nserver. The browser should show the current time and corresponding \nmessage below it. \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 60}}, {"text": "FastAPI \u2013 Python Web Framework \n \n56 \n \nLet us add another route \" /login\" to our application which renders a html \ntemplate having a simple login form. The HTML code for login page is as \nfollows: \n<html> \n   <body> \n      <form action=\"/submit\" method=\"POST\"> \n         <h3>Enter User name</h3> \n         <p><input type='text' name='nm'/></p> \n         <h3>Enter Password</h3> \n         <p><input type='password' name='pwd'/></p> \n         <p><input type='submit' value='Login'/></p> \n      </form>", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 61}}, {"text": "ype='password' name='pwd'/></p> \n         <p><input type='submit' value='Login'/></p> \n      </form> \n   </body> \n</html> \nNote that the action parameter is set to \"/submit\" route and action set to \nPOST. This will be significant for further discussion. \nAdd login() function in the main.py file as under: \n@app.get(\"/login/\", response_class=HTMLResponse) \nasync def login(request: Request): \n    return templates.TemplateResponse(\"login.html\", \n{\"request\": request}) \nThe URL http://localhost:8000/l", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 61}}, {"text": "urn templates.TemplateResponse(\"login.html\", \n{\"request\": request}) \nThe URL http://localhost:8000/login will render the login form as follows: \n15. FastAPI \u2013 HTML Form Templates ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 61}}, {"text": "FastAPI \u2013 Python Web Framework \n \n57 \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 62}}, {"text": "FastAPI \u2013 Python Web Framework \n \n58 \n \nNow we shall see how the HTML form data can be accessed in a FastAPI \noperation function. In the above example, the /login route renders a login \nform. The data entered by the user is submitted to /submit URL with POST \nas the request method. Now we have to provide a view function to process \nthe data submitted by the user. \nFastAPI has a Form class to process the data rece ived as a request by \nsubmitting an HTML form. However, you need to install the pyt", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 63}}, {"text": "ss the data rece ived as a request by \nsubmitting an HTML form. However, you need to install the python-\nmultipart module. It is a streaming multipart form parser for Python. \npip3 install python-multipart \nAdd Form class to the imported resources from FastAPI \nfrom fastapi import Form \nLet us define a submit() function to be decorated by @app.post(). In order \nto receive the form data, declare two parameters of Form type, having the \nsame name as the form attributes. \n@app.post(\"/submit/\") \nasy", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 63}}, {"text": "o parameters of Form type, having the \nsame name as the form attributes. \n@app.post(\"/submit/\") \nasync def submit(nm: str = Form(...), pwd: str = Form(...)): \n    return {\"username\": nm} \nPress submit after filling the text fields. The browser is redirected to /submit \nURL and the JSON response is rendered. Check the Swagger API docs of \nthe /submit route. It correctly identifies nm and pwd as the request body \nparameters and the form\u2019s  \"media type\" as application/x-www-form-\nurlencoded. \n16. F", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 63}}, {"text": " request body \nparameters and the form\u2019s  \"media type\" as application/x-www-form-\nurlencoded. \n16. FastAPI \u2013 Accessing Form Data ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 63}}, {"text": "FastAPI \u2013 Python Web Framework \n \n59 \n \n \nIt is even possible to populate and return Pydantic model with HTML form \ndata. In the following code, we declare User class as a Pydantic model and \nsend its object as the server\u2019 response. \nfrom pydantic import BaseModel \nclass User(BaseModel): \n    username:str \n    password:str \n \n@app.post(\"/submit/\", response_model=User) \nasync def submit(nm: str = Form(...), pwd: str = Form(...)): \n    return User(username=nm, password=pwd) \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 64}}, {"text": "orm(...), pwd: str = Form(...)): \n    return User(username=nm, password=pwd) \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 64}}, {"text": "FastAPI \u2013 Python Web Framework \n \n60 \n \nFirst of all, to send a file to the server you need to use the HTML form\u2019s \nenctype as multipart/form-data, and use the input type as the file to \nrender a button, which when clicked allows you to select a file from the file \nsystem. \n<html> \n   <body> \n      <form action=\"http://localhost:8000/uploader\" \nmethod=\"POST\" enctype=\"multipart/form-data\"> \n         <input type=\"file\" name=\"file\" /> \n         <input type=\"submit\"/> \n  </form> \n </body> \n</html>  ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 65}}, {"text": "  <input type=\"file\" name=\"file\" /> \n         <input type=\"submit\"/> \n  </form> \n </body> \n</html>  \nNote that the form\u2019s act ion parameter to the endpoint \nhttp://localhost:8000/uploader and the method is set to POST. \nThis HTML form is rendered as a template with following code: \nfrom fastapi import FastAPI, File, UploadFile, Request \nimport uvicorn \nimport shutil \n \nfrom fastapi.responses import HTMLResponse \nfrom fastapi.templating import Jinja2Templates \n \napp = FastAPI() \n \ntemplates = Jin", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 65}}, {"text": "t HTMLResponse \nfrom fastapi.templating import Jinja2Templates \n \napp = FastAPI() \n \ntemplates = Jinja2Templates(directory=\"templates\") \n17. FastAPI \u2013 Uploading Files ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 65}}, {"text": "FastAPI \u2013 Python Web Framework \n \n61 \n \n \n@app.get(\"/upload/\", response_class=HTMLResponse) \nasync def upload(request: Request): \n    return templates.TemplateResponse(\"uploadfile.html\", \n{\"request\": request}) \nVisit http://localhost:8000/upload/. You should get the form with Choose \nFile button. Click it to open the file to be uploaded. \n \nThe upload operation is handled by UploadFile function in FastAPI \nfrom fastapi import FastAPI, File, UploadFile \nimport shutil \n \n@app.post(\"/uploader/\") \na", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 66}}, {"text": " FastAPI \nfrom fastapi import FastAPI, File, UploadFile \nimport shutil \n \n@app.post(\"/uploader/\") \nasync def create_upload_file(file: UploadFile = File(...)): \n    with open(\"destination.png\", \"wb\") as buffer: \n        shutil.copyfileobj(file.file, buffer) \n     \n    return {\"filename\": file.filename} \nWe shall use shutil library in Python to copy the received file in the server \nlocation by the name destination.png \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 66}}, {"text": "ame destination.png \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 66}}, {"text": "FastAPI \u2013 Python Web Framework \n \n62 \n \nA cookie is one of the HTTP headers. The web server sends a response to \nthe client, in addition to the data requested, it also inserts one or more \ncookies. A cookie is a very small amount of data, that is stored  in the \nclient\u2019s machine. On subsequent connection requests from the same client, \nthis cookie data is also attached along with the HTTP requests.  \nThe cookies are useful for recording information about client\u2019s browsing. \nCookies are a reliabl", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 67}}, {"text": ".  \nThe cookies are useful for recording information about client\u2019s browsing. \nCookies are a reliable method of retrieving stateful information in otherwise \nstateless communication by HTTP protocol. \nIn FastAPI, the cookie parameter is set on the response object with the help \nof set_cookie() method \nresponse.set_cookie(key, value) \nExample \nHere is an example of set_cookie() method. We have a JSON response \nobject called content. Call the set_cookie() method on it to set a cookie \nas key=\"usrn", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 67}}, {"text": "ON response \nobject called content. Call the set_cookie() method on it to set a cookie \nas key=\"usrname\" and value=\"admin\": \nfrom fastapi import FastAPI \nfrom fastapi.responses import JSONResponse \n \napp = FastAPI() \n@app.post(\"/cookie/\") \ndef create_cookie(): \n    content = {\"message\": \"cookie set\"} \n    response = JSONResponse(content=content) \n    response.set_cookie(key=\"username\", value=\"admin\") \n    return response \nTo read back the cookie on a subsequent visit, use the Cookie object in th", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 67}}, {"text": "n\") \n    return response \nTo read back the cookie on a subsequent visit, use the Cookie object in the \nFastAPI library. \n18. FastAPI \u2013 Cookie Parameters ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 67}}, {"text": "FastAPI \u2013 Python Web Framework \n \n63 \n \nfrom fastapi import FastAPI, Cookie \napp = FastAPI() \n@app.get(\"/readcookie/\") \nasync def read_cookie(username: str = Cookie(None)): \n    return {\"username\": username} \nInspect these two endpoints in the Swagger API. There are these two routes \n\"/cookies\" and \"/readcookie\". Execute the create_cookie() function \nbound to \"/cookies\". The response is just the content, although the cookie \nis set. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 68}}, {"text": "ontent, although the cookie \nis set. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 68}}, {"text": "FastAPI \u2013 Python Web Framework \n \n64 \n \nWhen the read_cookie() function is executed, the cookie is read back and \nappears as the response. Also, not that the documentation identifies the \nuser name as a cookie parameter. \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 69}}, {"text": "FastAPI \u2013 Python Web Framework \n \n65 \n \nIn order to read the values of an HTTP header that is a part of the client \nrequest, import the Header object from the FastAPI library, and declare a \nparameter of Header type in the operation function definition. The name of \nthe parameter should match with the HTTP header converted in \ncamel_case.  \nIn the following example, the \"accept-language\" header is to be retrieved. \nSince Python doesn\u2019t allow \"-\" (dash) in the name of identifier, it is replaced \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 70}}, {"text": " to be retrieved. \nSince Python doesn\u2019t allow \"-\" (dash) in the name of identifier, it is replaced \nby \"_\" (underscore) \nfrom typing import Optional \nfrom fastapi import FastAPI, Header \n \napp = FastAPI() \n@app.get(\"/headers/\") \nasync def read_header(accept_language: Optional[str] = \nHeader(None)): \n    return {\"Accept-Language\": accept_language}  \nAs the following Swagger documentation shows, the retrieved header is \nshown as the response body. \n19. FastAPI \u2013 Header Parameters ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 70}}, {"text": " retrieved header is \nshown as the response body. \n19. FastAPI \u2013 Header Parameters ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 70}}, {"text": "FastAPI \u2013 Python Web Framework \n \n66 \n \n \nYou can push custom as well as predefined headers in the response object. \nThe operation function should have a parameter of Response type. In order \nto set a custom header, its name should be prefixed with \"X\". In the \nfollowing case, a custom header called \"X -Web-Framework\" and a \npredefined header \u201cContent-Language\" is added along with the response of \nthe operation function. \nfrom fastapi import FastAPI \nfrom fastapi.responses import JSONResponse \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 71}}, {"text": "\nthe operation function. \nfrom fastapi import FastAPI \nfrom fastapi.responses import JSONResponse \n \napp = FastAPI() \n \n@app.get(\"/rspheader/\") \ndef set_rsp_headers(): \n    content = {\"message\": \"Hello World\"} \n    headers = {\"X-Web-Framework\": \"FastAPI\", \"Content-Language\": \"en-US\"} \n    return JSONResponse(content=content, headers=headers)  \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 71}}, {"text": "FastAPI \u2013 Python Web Framework \n \n67 \n \nThe newly added headers will appear in the response header section of the \ndocumentation. \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 72}}, {"text": "FastAPI \u2013 Python Web Framework \n \n68 \n \nAn operation function returns A JSON response to the client. The response \ncan be in the form of Python primary types , i.e., numbers, string, list or \ndict, etc. It can also be in the form of a Pydantic model. For a function to \nreturn a model object, the operation decorator should declare a \nrespone_model parameter. \nWith the help of response_model, FastAPI Converts the output data to a \nstructure of a model class. It validates the data, adds a JSON Sche", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 73}}, {"text": "I Converts the output data to a \nstructure of a model class. It validates the data, adds a JSON Schema for \nthe response, in the OpenAPI path operation.  \nOne of the important advantages of response_model parameter is that we \ncan format the output by selecting the fields from the model to cast the \nresponse to an output model. \nExample \nIn the following example, the POST operation decorator r eceives the \nrequest body in the form of an object of the student class (a subclass of \nBaseModel). As ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 73}}, {"text": "ives the \nrequest body in the form of an object of the student class (a subclass of \nBaseModel). As one of the fields in this class, i.e. marks (a list of marks) is \nnot needed in the response, we define another model called percent and \nuse it as the response_model parameter. \nfrom typing import List \nfrom fastapi import FastAPI \nfrom pydantic import BaseModel, Field \n \napp = FastAPI() \n \nclass student(BaseModel): \n    id: int \n    name :str = Field(None, title=\"name of student\", max_length=10)", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 73}}, {"text": "tudent(BaseModel): \n    id: int \n    name :str = Field(None, title=\"name of student\", max_length=10) \n    marks: List[int] = [] \n    percent_marks: float \nclass percent(BaseModel): \n20. FastAPI \u2013 Response Model ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 73}}, {"text": "FastAPI \u2013 Python Web Framework \n \n69 \n \n    id:int \n    name :str = Field(None, title=\"name of student\", max_length=10) \n    percent_marks: float \n \n@app.post(\"/marks\", response_model=percent) \nasync def get_percent(s1:student): \n    s1.percent_marks=sum(s1.marks)/2 \n    return s1 \nIf we check the Swagger documentation, it shows that the \"/marks\" route \ngets an object of student class as the request body. Populate the attributes \nwith appropriate values and execute the get_percent() function. \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 74}}, {"text": "st body. Populate the attributes \nwith appropriate values and execute the get_percent() function. \n \nThe server response is cast to the percent class as it has been used as the \nresponse_model. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 74}}, {"text": "FastAPI \u2013 Python Web Framework \n \n70 \n \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 75}}, {"text": "FastAPI \u2013 Python Web Framework \n \n71 \n \nEach attribute of a Pydantic model has a type. The type can be a built -in \nPython type or a model itself. Hence it is possible to declare nested JSON \n\"objects\" with specific attribute names, types, and validations.  \nExample \nIn the following example, we construct a customer model with one of the \nattributes as product model class. The product model in turn has an \nattribute of supplier class. \nfrom typing import Tuple \nfrom fastapi import FastAPI \nfrom ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 76}}, {"text": "n has an \nattribute of supplier class. \nfrom typing import Tuple \nfrom fastapi import FastAPI \nfrom pydantic import BaseModel \napp = FastAPI() \n \nclass supplier(BaseModel): \n    supplierID:int \n    supplierName:str \n \nclass product(BaseModel): \n    productID:int \n    prodname:str \n    price:int \n    supp:supplier \n \nclass customer(BaseModel): \n    custID:int \n    custname:str \n    prod:Tuple[product] \n21. FastAPI \u2013 Nested Models ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 76}}, {"text": "ct] \n21. FastAPI \u2013 Nested Models ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 76}}, {"text": "FastAPI \u2013 Python Web Framework \n \n72 \n \nThe following POST operation decorator renders the object of the customer \nmodel as the server response. \n@app.post('/invoice') \nasync def getInvoice(c1:customer): \n    return c1 \nThe swagger UI page reveals the presence of three schemas, corresponding \nto three BaseModel classes.  \n \nThe Customer schema when expanded to show all the nodes looks like this: \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 77}}, {"text": "FastAPI \u2013 Python Web Framework \n \n73 \n \n \nAn example response of \"/invoice\" route should be as follows: \n{ \n  \"custID\": 1, \n  \"custname\": \"Jay\", \n  \"prod\": [ \n    { \n      \"productID\": 1, \n      \"prodname\": \"LAPTOP\", \n      \"price\": 40000, \n      \"supp\": { \n        \"supplierID\": 1, \n        \"supplierName\": \"Dell\" \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 78}}, {"text": "FastAPI \u2013 Python Web Framework \n \n74 \n \n      } \n    } \n  ] \n} \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 79}}, {"text": "FastAPI \u2013 Python Web Framework \n \n75 \n \nThe built-in dependency injection system of FastAPI makes it possible to \nintegrate components easier when building your API. In programming, \nDependency injection refers to the mechanism where an object receives \nother objects that it depends on. The other objects are called dependencies. \nDependency injection has the following advantages: \n\uf0b7 reuse the same shared logic \n \n\uf0b7 share database connections \n \n\uf0b7 enforce authentication and security features \n \nA", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 80}}, {"text": " shared logic \n \n\uf0b7 share database connections \n \n\uf0b7 enforce authentication and security features \n \nAssuming that a FastAPI app has two operation functions both having th e \nsame query parameters id, name and age. \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.get(\"/user/\") \nasync def user(id: str, name: str, age: int): \n    return {\"id\": id, \"name\": name, \"age\": age} \n \n@app.get(\"/admin/\") \nasync def admin(id: str, name: str, age: int): \n    return {\"id\": id, \"name\": name, \"age\": age} \nIn", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 80}}, {"text": "\nasync def admin(id: str, name: str, age: int): \n    return {\"id\": id, \"name\": name, \"age\": age} \nIn case of any changes such as adding/removing query parameters, both \nthe route decorators and functions need to be changed.  \nFastAPI provides Depends class and its object is used as a common \nparameter in such cases. First import Depends from FastAPI and define a \nfunction to receive these parameters: \nasync def dependency(id: str, name: str, age: int): \n    return {\"id\": id, \"name\": name, \"age\":", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 80}}, {"text": "rs: \nasync def dependency(id: str, name: str, age: int): \n    return {\"id\": id, \"name\": name, \"age\": age} \n22. FastAPI \u2013 Dependencies ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 80}}, {"text": "FastAPI \u2013 Python Web Framework \n \n76 \n \nNow we can use the return value of this function as a parameter in operation \nfunctions \n@app.get(\"/user/\") \nasync def user(dep: dict = Depends(dependency)): \n    return dep \nFor each new Request, FastAPI calls the dependency function using the \ncorresponding parameters, returns the result, and assigns the result to your \noperation. \nYou can use a class for managing dependencies instead of a function. \nDeclare a class with id, name and age as attributes. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 81}}, {"text": "managing dependencies instead of a function. \nDeclare a class with id, name and age as attributes. \nclass dependency: \n    def __init__(self, id: str, name: str, age: int): \n        self.id = id \n        self.name = name \n        self.age = age  \nUse this class as the type of parameters. \n@app.get(\"/user/\") \nasync def user(dep: dependency = Depends(dependency)): \n    return dep \n \n@app.get(\"/admin/\") \nasync def admin(dep: dependency = Depends(dependency)): \n    return dep \nHere, we used the depe", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 81}}, {"text": "/\") \nasync def admin(dep: dependency = Depends(dependency)): \n    return dep \nHere, we used the dependency injection in the operation function. It can \nalso be used as operation decoration. For example, we want to check if the \nvalue of query parameter age is less than 21. If yes it should throw an \nexception. So, we write a function to check it and use it as a dependency. \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 81}}, {"text": "FastAPI \u2013 Python Web Framework \n \n77 \n \nasync def validate(dep: dependency = Depends(dependency)): \n    if dep.age < 18: \n        raise HTTPException(status_code=400, detail=\"You are \nnot eligible\") \n@app.get(\"/user/\", dependencies=[Depends(validate)]) \nasync def user(): \n    return {\"message\": \"You are eligible\"} \nIn FastAPI dependency management, you can use yield instead of return to \nadd some extra steps. For example, the following function uses database \ndependency with yield. \nasync def ge", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 82}}, {"text": "extra steps. For example, the following function uses database \ndependency with yield. \nasync def get_db(): \n    db = DBSession() \n    try: \n        yield db \n    finally: \n        db.close() ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 82}}, {"text": "FastAPI \u2013 Python Web Framework \n \n78 \n \nCross-Origin Resource Sharing  (CORS) is a situation when a frontend  \napplication that is running on one client browser tries to communicate with \na backend through JavaScript code, and the backend is in a different \"origin\" \nthan the frontend.  The origin here is a combination of protocol, domain \nname, and port numbers. As a result, http://localhost and https://localhost \nhave different origins. \nIf the browser with a URL of one origin sends a request f", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 83}}, {"text": "ttps://localhost \nhave different origins. \nIf the browser with a URL of one origin sends a request for the execution of \nJavaScript code from another origin, the browser sends an OPTIONS HTTP \nrequest. \nIf the backend authorizes the communication from this different origin by  \nsending the appropriate headers it will let the JavaScript in the frontend \nsend its request to the backend. For that, the backend must have a list of \n\"allowed origins\". \nTo specify explicitly the allowed origins, import", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 83}}, {"text": "e backend must have a list of \n\"allowed origins\". \nTo specify explicitly the allowed origins, import CORSMiddleware and add \nthe list of origins to the app's middleware. \nfrom fastapi import FastAPI \nfrom fastapi.middleware.cors import CORSMiddleware \n \napp = FastAPI() \n \norigins = [ \n    \"http://192.168.211.:8000\", \n    \"http://localhost\", \n    \"http://localhost:8080\", \n] \n \napp.add_middleware( \n    CORSMiddleware, \n    allow_origins=origins, \n23. FastAPI \u2013 CORS ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 83}}, {"text": "    CORSMiddleware, \n    allow_origins=origins, \n23. FastAPI \u2013 CORS ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 83}}, {"text": "FastAPI \u2013 Python Web Framework \n \n79 \n \n    allow_credentials=True, \n    allow_methods=[\"*\"], \n    allow_headers=[\"*\"], \n) \n \n@app.get(\"/\") \nasync def main(): \n    return {\"message\": \"Hello World\"} \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 84}}, {"text": "FastAPI \u2013 Python Web Framework \n \n80 \n \nThe REST architecture uses HTTP verbs or methods for the operation on the \nresources. The POST, GET, PUT and DELETE methods perform respectively \nCREATE, READ, UPDATE and DELETE operations respectively. \nIn the following example, we shall use a Python list as an in -memory \ndatabase and perf orm the CRUD operations on it. First, let us set up a \nFastAPI app object and declare a Pydantic model called Book. \nfrom fastapi import FastAPI \nfrom pydantic import ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 85}}, {"text": "object and declare a Pydantic model called Book. \nfrom fastapi import FastAPI \nfrom pydantic import BaseModel \n \napp = FastAPI() \n \ndata = [] \n \nclass Book(BaseModel): \n    id: int \n    title: str \n    author: str \n    publisher: str \nAn object of this model is populated using the @app.post() decorator and \nit is appended to the list of books (data is declared for the list of books) \n@app.post(\"/book\") \ndef add_book(book: Book): \n    data.append(book.dict()) \n    return data \nIn the Swagger UI, ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 85}}, {"text": "ook\") \ndef add_book(book: Book): \n    data.append(book.dict()) \n    return data \nIn the Swagger UI, execute this operation function a couple of times and \nadd some data. \n24. FastAPI \u2013 CRUD Operations ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 85}}, {"text": "FastAPI \u2013 Python Web Framework \n \n81 \n \n \nThe server\u2019s JSON response shows the list of books added so far. \n \nTo retrieve the list, define an operation function bound to the @app.get() \ndecorator as follows: \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 86}}, {"text": "FastAPI \u2013 Python Web Framework \n \n82 \n \n@app.get(\"/list\") \ndef get_books(): \n    return data \nTo retrieve a book with its id as a path parameter, define the get() operation \ndecorator and get_book() function as below: \n@app.get(\"/book/{id}\") \ndef get_book(id: int): \n    id = id - 1 \n    return data[id] \nThe /list route retrieves all the books. ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 87}}, {"text": "FastAPI \u2013 Python Web Framework \n \n83 \n \n \nOn the other hand, use \"id\" as the path parameter in the \"/book/1\" route.  \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 88}}, {"text": "FastAPI \u2013 Python Web Framework \n \n84 \n \n \nThe book with \"id=1\" will be retrieved as can be seen in the server response \nof Swagger UI \n \nNext, define @app.put() decorator that modifies an object in the data list. \nThis decorator too has a path parameter for the id field. \n@app.put(\"/book/{id}\") \ndef add_book(id: int, book: Book): \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 89}}, {"text": "FastAPI \u2013 Python Web Framework \n \n85 \n \n    data[id-1] = book \n    return data \nInspect this operation function in the swagger UI . Give id=1, and change \nvalue of publisher to BPB in the request body. \n \nWhen executed, the response shows the list with object with id=1 updated \nwith the new values. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 90}}, {"text": "FastAPI \u2013 Python Web Framework \n \n86 \n \n \nFinally, we define the @app.delete() decorator to delete an object \ncorresponding to the path parameter. \n@app.delete(\"/book/{id}\") \ndef delete_book(id: int): \n    data.pop(id-1) \n    return data \nGive id=1 as the path parameter and execute the function. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 91}}, {"text": "FastAPI \u2013 Python Web Framework \n \n87 \n \n \nUpon execution, the list now shows only two objects. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 92}}, {"text": "FastAPI \u2013 Python Web Framework \n \n88 \n \nIn the previo us chapter, a Python list has been used as an in -memory \ndatabase to perform CRUD operations using FastAPI. Instead, we can use \nany relational database (such as MySQL, Oracle, etc.) to perform store, \nretrieve, update and delete operations. \nInstead of using a DB-API compliant database driver, we shall use \nSQLAlchemy as an interface between Python code and a database (we are \ngoing to use SQLite database as Python has in -built support for", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 93}}, {"text": "Python code and a database (we are \ngoing to use SQLite database as Python has in -built support for it). \nSQLAlchemy is a popular SQL toolkit and Object Relational Mapper. \nObject Relational Mapping is a programming technique for converting data \nbetween incompatible type systems in object -oriented programming \nlanguages. Usually, the type system used in an Object -Oriented language \nlike Python contains non -scalar types. However, data types in most of the \ndatabase products such as Oracle, M", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 93}}, {"text": " contains non -scalar types. However, data types in most of the \ndatabase products such as Oracle, MySQL, etc., are of primitive types such \nas integers and strings. \nIn an ORM system, each class maps to a table in the underlying database. \nInstead of writing tedious database interfacing code yourself, an ORM takes \ncare of these issues for you while you can focus on programming the logics \nof the system. \nIn order to use SQLAlchemy, we need to first install the library using the \nPIP installer.", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 93}}, {"text": " system. \nIn order to use SQLAlchemy, we need to first install the library using the \nPIP installer. \npip install sqlalchemy \nSQLAlchemy is designed to operat e with a DBAPI implementation built for \na particular database. It uses dialect system to communicate with various \ntypes of DBAPI implementations and databases. All dialects require that an \nappropriate DBAPI driver is installed.  \nThe following are the dialects included \u2212 \n\uf0b7 Firebird \n\uf0b7 Microsoft SQL Server \n\uf0b7 MySQL \n\uf0b7 Oracle \n\uf0b7 PostgreS", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 93}}, {"text": "owing are the dialects included \u2212 \n\uf0b7 Firebird \n\uf0b7 Microsoft SQL Server \n\uf0b7 MySQL \n\uf0b7 Oracle \n\uf0b7 PostgreSQL \n25. FastAPI \u2013 SQL Databases ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 93}}, {"text": "FastAPI \u2013 Python Web Framework \n \n89 \n \n\uf0b7 SQLite \n\uf0b7 Sybase \nSince we are going to use SQLite database, we need to create a database \nengine for our database called test.db. Import create_engine() function \nfrom sqlalchemy module. \nfrom sqlalchemy import create_engine \nfrom sqlalchemy.dialects.sqlite import * \nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\" \nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args = \n{\"check_same_thread\": False}) \nIn order to interact with the database, we  n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 94}}, {"text": "SE_URL, connect_args = \n{\"check_same_thread\": False}) \nIn order to interact with the database, we  need to obtain its handle. A \nsession object is the handle to database. Session class is defined using \nsessionmaker() \u2013 a configurable session factory method which is bound \nto the engine object. \nfrom sqlalchemy.orm import sessionmaker, Session \nsession = sessionmaker(autocommit=False, autoflush=False, \nbind=engine) \nNext, we need a declarative base class that stores a catalog of classes and \nmap", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 94}}, {"text": "lse, \nbind=engine) \nNext, we need a declarative base class that stores a catalog of classes and \nmapped tables in the Declarative system.  \nfrom sqlalchemy.ext.declarative import declarative_base \nBase = declarative_base() \nBooks, a subclass of Base, is mapped to a book table in the database. \nAttributes in the Books class correspond to the data types of the columns \nin the target table. Note that the id attribute corresponds to the primary \nkey in the book table. \nfrom sqlalchemy import Column,", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 94}}, {"text": " the id attribute corresponds to the primary \nkey in the book table. \nfrom sqlalchemy import Column, Integer, String \nclass Books(Base): \n    __tablename__ = 'book' \n    id = Column(Integer, primary_key=True, nullable=False) \n    title = Column(String(50), unique=True) ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 94}}, {"text": "FastAPI \u2013 Python Web Framework \n \n90 \n \n    author = Column(String(50)) \n    publisher = Column(String(50)) \nBase.metadata.create_all(bind=engine) \nThe create_all() method creates the corresponding tables in the database. \nWe now have to declare a Pydantic model that corresponds to the \ndeclarative base subclass (Books class defined above). \nfrom typing import List \nfrom pydantic import BaseModel, constr \n \nclass Book(BaseModel): \n    id: int \n    title: str \n    author:str \n    publisher: str \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 95}}, {"text": " constr \n \nclass Book(BaseModel): \n    id: int \n    title: str \n    author:str \n    publisher: str \n \n    class Config: \n        orm_mode = True \nNote the use of orm_mode=True in the config class indicating that it is \nmapped with the ORM class of SQLAlchemy. \nRest of the code is just similar to in -memory CRUD operations, with the \ndifference being the operation functions interact with the database through \nSQLalchemy interface. The POST operation on the FastAPI application \nobject is defined b", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 95}}, {"text": "se through \nSQLalchemy interface. The POST operation on the FastAPI application \nobject is defined below: \nfrom fastapi import FastAPI, Depends \napp=FastAPI() \n \ndef get_db(): \n    db = session() \n    try: \n        yield db \n    finally: ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 95}}, {"text": "FastAPI \u2013 Python Web Framework \n \n91 \n \n        db.close() \n \n@app.post('/add_new', response_model=Book) \ndef add_book(b1: Book, db: Session = Depends(get_db)): \n    bk=Books(id=b1.id, title=b1.title, author=b1.author, \npublisher=b1.publisher) \n    db.add(bk) \n    db.commit() \n    db.refresh(bk) \n    return Books(**b1.dict()) \nA database session is first established. Data from the POST request body is \nadded to the book table as a new row. Execute the add_book() operation \nfunction to add sample", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 96}}, {"text": "y is \nadded to the book table as a new row. Execute the add_book() operation \nfunction to add sample data to the books table. To verify, you can use \nSQLiteStudio, a GUI tool for SQLite databases. \n \nTwo operation functions for GET operation are defined, one for fetching all \nthe records, and one for the record matching a path parameter. \nFollowing is the get_books() function bound to the /list route. When \nexecuted, its server response is the list of all records. \n@app.get('/list', response_mod", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 96}}, {"text": "ute. When \nexecuted, its server response is the list of all records. \n@app.get('/list', response_model=List[Book]) \ndef get_books(db: Session = Depends(get_db)): \n    recs = db.query(Books).all() \n    return recs \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 96}}, {"text": "FastAPI \u2013 Python Web Framework \n \n92 \n \nThe /book/{id} route calls the get_book() function with id as path \nparameter. The SQLAlchemy\u2019s query returns an object corresponding to the \ngiven id. \n@app.get('/book/{id}', response_model=Book) \ndef get_book(id:int, db: Session = Depends(get_db)): \n    return db.query(Books).filter(Books.id == id).first() \nThe following image shows the result of get_books() function executed \nfrom the Swagger UI. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 97}}, {"text": "() function executed \nfrom the Swagger UI. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 97}}, {"text": "FastAPI \u2013 Python Web Framework \n \n93 \n \nThe update and delete operations are performed by update_book() \nfunction (executed when /update/{id} route is visited) and del_book() \nfunction called when the route /delete/{id} is given in as the URL. \n@app.put('/update/{id}', response_model=Book) \ndef update_book(id:int, book:Book, db: Session = Depends(get_db)): \n    b1 = db.query(Books).filter(Books.id == id).first() \n    b1.id=book.id \n    b1.title=book.title \n    b1.author=book.author \n    b1.publi", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 98}}, {"text": " == id).first() \n    b1.id=book.id \n    b1.title=book.title \n    b1.author=book.author \n    b1.publisher=book.publisher \n    db.commit() \n    return db.query(Books).filter(Books.id == id).first() \n \n@app.delete('/delete/{id}') \ndef del_book(id:int, db: Session = Depends(get_db)): \n    try: \n        db.query(Books).filter(Books.id == id).delete() \n        db.commit() \n    except Exception as e: \n        raise Exception(e) \n    return {\"delete status\": \"success\"} \nIf you intend to use any other da", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 98}}, {"text": "      raise Exception(e) \n    return {\"delete status\": \"success\"} \nIf you intend to use any other database in place of SQLite, you need to only \nthe change the dialect definition accordingly. For example, to use MySQL \ndatabase and pymysql driver, change the statement of engine object t o \nthe following: \nengine = \ncreate_engine('mysql+pymysql://user:password@localhost/test') \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 98}}, {"text": "FastAPI \u2013 Python Web Framework \n \n94 \n \nFastAPI can also use NoSQL databases such as MongoDB, Cassandra, \nCouchDB, etc. as the backend for the CRUD operations of a REST app. In \nthis topic, we shall see how to use MongoDB in a FastAPI application. \nMongoDB is a d ocument oriented database, in which t he semi-structured \ndocuments are stored in formats like JSON. Documents can contain many \ndifferent key-value pairs, or key-array pairs, or even nested documents. It \nis a collection of key-value p", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 99}}, {"text": "nt key-value pairs, or key-array pairs, or even nested documents. It \nis a collection of key-value pairs, similar to Python dictionary object. One or \nmore such documents are stored in a Collection.  \nA Collection in MongoDB is equivalent to a table in relational database. \nHowever, MongoDB (as do all the NoSQL databases) doesn't have a \npredefined schema. A Document is similar to single row in a table of SQL \nbased relational database. Each document may be of variable number of \nkey-value pairs", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 99}}, {"text": "table of SQL \nbased relational database. Each document may be of variable number of \nkey-value pairs. Thus MongoDB is a schema-less database. \nTo use MongoDB with FastAPI, MongoDB server must be installed on the \nmachine. We also need to install PyMongo, an official Python driver for \nMongoDB. \npip3 install pymongo \nBefore interacting with MongoDB database through Python and FastAPI \ncode, ensure that MongoDB is running by issuing following command \n(assuming that MongoDB server is installed in ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 99}}, {"text": "that MongoDB is running by issuing following command \n(assuming that MongoDB server is installed in e:\\mongodb folder). \nE:\\mongodb\\bin>mongod \n.. \nwaiting for connections on port 27017  \nAn object of MongoClient class in the PyMongo module is the handle using \nwhich Python interacts with MongoDB server. \nfrom pymongo import MongoClient \nclient=MongoClient() \n26. FastAPI \u2013 Using MongoDB ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 99}}, {"text": "FastAPI \u2013 Python Web Framework \n \n95 \n \nWe define Book as the BaseModel class to populate the request body (same \nas the one used in the SQLite example) \nfrom pydantic import BaseModel \nfrom typing import List \nclass Book(BaseModel): \n    bookID: int \n    title: str \n    author:str \n    publisher: str \nSet up the FastAPI application object: \nfrom fastapi import FastAPI, status \napp = FastAPI() \nThe POST operation decorator has \"/add_new\" as URL route and executes \nadd_book() function. It parses ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 100}}, {"text": "e POST operation decorator has \"/add_new\" as URL route and executes \nadd_book() function. It parses the Book BaseModel object into a dictionary \nand adds a document in the BOOK_COLLECTION of test database. \n@app.post(\"/add_new\", status_code=status.HTTP_201_CREATED) \ndef add_book(b1: Book): \n    \"\"\"Post a new message to the specified channel.\"\"\" \n    with MongoClient() as client: \n        book_collection = client[DB][BOOK_COLLECTION] \n        result = book_collection.insert_one(b1.dict()) \n      ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 100}}, {"text": "ection = client[DB][BOOK_COLLECTION] \n        result = book_collection.insert_one(b1.dict()) \n        ack = result.acknowledged \n        return {\"insertion\": ack} \nAdd a few documents using the web interface of Swagger UI by visiting \nhttp://localhost:8000/docs. You can verify the collection in the Compass \nGUI front end for MongoDB. ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 100}}, {"text": "FastAPI \u2013 Python Web Framework \n \n96 \n \n \nTo retrieve the list of all books, let us include the following get operation \nfunction \u2013 get_books(). It will be executed when \" /books\" URL route is \nvisited. \n@app.get(\"/books\", response_model=List[str]) \ndef get_books(): \n    \"\"\"Get all books in list form.\"\"\" \n    with MongoClient() as client: \n        book_collection = client[DB][BOOK_COLLECTION] \n        booklist = book_collection.distinct(\"title\") \n        return booklist \nIn this case, the server", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 101}}, {"text": "     booklist = book_collection.distinct(\"title\") \n        return booklist \nIn this case, the server response will be the list of all titles in the books \ncollection. \n[ \n  \"Computer Fundamentals\", \n  \"Python Cookbook\", \n  \"Let Us Python\" \n] \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 101}}, {"text": "FastAPI \u2013 Python Web Framework \n \n97 \n \nThis following GET decorator retrieves a book document corresponding to \ngiven ID as path parameter: \n@app.get(\"/books/{id}\", response_model=Book) \ndef get_book(id: int): \n    \"\"\"Get all messages for the specified channel.\"\"\" \n    with MongoClient() as client: \n        book_collection = client[DB][BOOK_COLLECTION] \n        b1 = book_collection.find_one({\"bookID\": id}) \n        return b1 \nSwagger UI documentation page shows the following interface: \n \n \n \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 102}}, {"text": "kID\": id}) \n        return b1 \nSwagger UI documentation page shows the following interface: \n \n \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 102}}, {"text": "FastAPI \u2013 Python Web Framework \n \n98 \n \nThe server\u2019s JSON response, when the above function is executed, is as \nfollows: \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 103}}, {"text": "FastAPI \u2013 Python Web Framework \n \n99 \n \nFacebook developed GraphQL in 2012, a new API standard with the \nintention of optimizing RESTful API Calls. GraphQL is the data query and \nmanipulation language for the API. GraphQL is more flexible, efficient, and \naccurate as compared to REST. A  GraphQL server provides only a single \nendpoint and responds with the precise data required by the client. \nAs GraphQL is compatible with ASGI, it can be easily i ntegrated with a \nFastAPI application. There are", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 104}}, {"text": "GraphQL is compatible with ASGI, it can be easily i ntegrated with a \nFastAPI application. There are many Python libraries for GraphQL. Some of \nthem are listed below: \n\uf0b7 Strawberry  \n\uf0b7 Ariadne \n\uf0b7 Tartiflette \n\uf0b7 Graphene \nFastAPI\u2019s official documentation recommends using Strawberry library as \nits design is also based on type annotations (as in the case of FastAPI itself). \nIn order to integrate GraphQL with a FastAPI app, first decorate a Python \nclass as Strawberry type. \n@strawberry.type \ncla", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 104}}, {"text": "raphQL with a FastAPI app, first decorate a Python \nclass as Strawberry type. \n@strawberry.type \nclass Book: \n    title: str \n    author: str \n    price: int  \nNext, declare a Query class containing a function that returns a Book \nobject. \n@strawberry.type \nclass Query: \n    @strawberry.field \n    def book(self) -> Book: \n        return Book(title=\"Computer Fundamentals\", \nauthor=\"Sinha\", price=300) \n27. FastAPI \u2013 Using GraphQL ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 104}}, {"text": "0) \n27. FastAPI \u2013 Using GraphQL ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 104}}, {"text": "FastAPI \u2013 Python Web Framework \n \n100 \n \nUse this Query class as the parameter to obtain Strawberry.Schema object. \nschema = strawberry.Schema(query=Query) \nThen declare the objects of both GraphQL class and FastAPI application class. \ngraphql_app = GraphQL(schema) \napp = FastAPI() \nFinally, add routes to the FastAPI object and run the server. \napp.add_route(\"/book\", graphql_app) \napp.add_websocket_route(\"/book\", graphql_app) \nVisit http://localhost:8000/book in the browser. An in -browser Graph", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 105}}, {"text": "t_route(\"/book\", graphql_app) \nVisit http://localhost:8000/book in the browser. An in -browser GraphQL \nIDE opens up. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 105}}, {"text": "FastAPI \u2013 Python Web Framework \n \n101 \n \nBelow the commented section, enter the following query using the Explorer \nbar of the Graphiql IDE. Run the query to display the result in the output \npane. \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 106}}, {"text": "FastAPI \u2013 Python Web Framework \n \n102 \n \nA WebSocket is a persistent connection between a client and server  to \nprovide bidirectional, full-duplex communication between the two. The \ncommunication takes place over HTTP through a single TCP/IP socket \nconnection. It can be seen as an upgrade of HTTP instead of a protocol \nitself.  \nOne of the limitations of HTTP is that it is a strictly half -duplex or \nunidirectional protocol. With WebSockets, on the other hand, we can send \nmessage-based data,", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 107}}, {"text": "ex or \nunidirectional protocol. With WebSockets, on the other hand, we can send \nmessage-based data, similar to UDP, but with the reliability of TCP. \nWebSocket uses HTTP as the initial transport mechanism, but keeps the \nTCP connection alive the connection after the HTTP resp onse is received . \nSame connection object it can be used two-way communication  between \nclient and server. Thus, real-time applications can be built using WebSocket \nAPIs. \nFastAPI supports WebSockets through WebSocket c", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 107}}, {"text": "me applications can be built using WebSocket \nAPIs. \nFastAPI supports WebSockets through WebSocket class in FastAPI module. \nFollowing exampl e demonstrates functioning of WebSocket in FastAPI \napplication. \nFirst we have an index() function that renders a template (socket.html). It \nis bound to \"/\" route. The HTML file socket.html is placed in the \u201ctemplates\u201d \nfolder. \nmain.py \nfrom fastapi import FastAPI,  Request \nfrom fastapi.responses import HTMLResponse \nfrom fastapi.templating import Jinj", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 107}}, {"text": "t FastAPI,  Request \nfrom fastapi.responses import HTMLResponse \nfrom fastapi.templating import Jinja2Templates \ntemplates = Jinja2Templates(directory=\"templates\") \n \nfrom fastapi.staticfiles import StaticFiles \n \napp = FastAPI() \n \napp.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\") \n \n28. FastAPI \u2013 WebSockets ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 107}}, {"text": "FastAPI \u2013 Python Web Framework \n \n103 \n \n@app.get(\"/\", response_class=HTMLResponse) \nasync def index(request: Request): \n    return templates.TemplateResponse(\"socket.html\", {\"request\": \nrequest}) \nThe template file renders a text box and a button. \nsocket.html \n<!DOCTYPE html> \n<html> \n    <head> \n        <title>Chat</title> \n  <script src=\"{{ url_for('static', \npath='ws.js') }}\"></script> \n    </head> \n    <body>  \n        <h1>WebSocket Chat</h1> \n        <form action=\"\" onsubmit=\"sendMessage(", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 108}}, {"text": "/head> \n    <body>  \n        <h1>WebSocket Chat</h1> \n        <form action=\"\" onsubmit=\"sendMessage(event)\"> \n            <input type=\"text\" id=\"messageText\" \nautocomplete=\"off\"/> \n            <button>Send</button> \n        </form> \n        <ul id='messages'> \n        </ul> \n    </body>  \n</html> \nInside the socket.html, there is a call to the JavaScript function to be \nexecuted on the form\u2019s  submit. Hence, to serve JavaScript, the \"static\" \nfolder is first mounted. The JavaScript file  ws.js i", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 108}}, {"text": "mit. Hence, to serve JavaScript, the \"static\" \nfolder is first mounted. The JavaScript file  ws.js is placed in the \"static\"  \nfolder. \n \n \nws.js ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 108}}, {"text": "FastAPI \u2013 Python Web Framework \n \n104 \n \nvar ws = new WebSocket(\"ws://localhost:8000/ws\"); \nws.onmessage = function(event) { \n var messages = document.getElementById('messages') \n var message = document.createElement('li') \n var content = document.createTextNode(event.data) \n message.appendChild(content) \n messages.appendChild(message) \n}; \nfunction sendMessage(event) { \n var input = document.getElementById(\"messageText\") \n ws.send(input.value) \n input.value = '' \n event.preventDefault() \n} \nAs ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 109}}, {"text": "lementById(\"messageText\") \n ws.send(input.value) \n input.value = '' \n event.preventDefault() \n} \nAs the JavaScript code is loaded, it creates a websocket listening at \n\"ws://localhost:8000/ws\". The sendMessage() function directs the input \nmessage to the WebSocket URL. \nThis route invokes the websocket_endpoint() function in the application \ncode. The incoming connection request is accepted and the incoming \nmessage is echoed on the client browser.  Add the below code to main.py. \nfrom fastapi i", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 109}}, {"text": "e incoming \nmessage is echoed on the client browser.  Add the below code to main.py. \nfrom fastapi import WebSocket \n@app.websocket(\"/ws\") \nasync def websocket_endpoint(websocket: WebSocket): \n    await websocket.accept() \n    while True: \n        data = await websocket.receive_text() \n        await websocket.send_text(f\"Message text was: {data}\") \nSave the FastAPI code file (main.py), template (socket.html) and JavaScript \nfile (ws.js). Run the Uvicorn server and visit http://localhost:8000/ to", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 109}}, {"text": "ocket.html) and JavaScript \nfile (ws.js). Run the Uvicorn server and visit http://localhost:8000/ to \nrender the chat window as below: ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 109}}, {"text": "FastAPI \u2013 Python Web Framework \n \n105 \n \n \nType a certain text and press Sen d button. The input message will be \nredirected on the browser through the websocket. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 110}}, {"text": "FastAPI \u2013 Python Web Framework \n \n106 \n \nEvent handlers are the functions to be executed when a certain identified \nevent occurs. In FastAPI, two such events are identified \u2013 startup and \nshutdown. FastAPI\u2019s application object has on_event() decorator that \nuses one of these events as an argument. The function registered with this \ndecorator is fired when the corresponding event occurs. \nThe startup event occurs before the development  server starts and the \nregistered function is typically used", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 111}}, {"text": "up event occurs before the development  server starts and the \nregistered function is typically used to perform certain initialization tasks, \nestablishing connection with the database etc. The event handler of \nshutdown event is called just before the application shutdown. \nExample \nHere is a simpl e example of startup and shutdown event handlers. As the \napp starts, the starting time is echoed in the console log. Similarly, when \nthe server is stopped by pressing ctrl+c, the shutdown time is a", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 111}}, {"text": "n the console log. Similarly, when \nthe server is stopped by pressing ctrl+c, the shutdown time is also \ndisplayed. \nmain.py \nfrom fastapi import FastAPI \nimport datetime \n \napp = FastAPI() \n \n@app.on_event(\"startup\") \nasync def startup_event(): \n    print('Server started :', datetime.datetime.now()) \n \n@app.on_event(\"shutdown\") \nasync def shutdown_event(): \n    print('server Shutdown :', datetime.datetime.now())     \n29. FastAPI \u2013 FastAPI Event Handlers ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 111}}, {"text": ".datetime.now())     \n29. FastAPI \u2013 FastAPI Event Handlers ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 111}}, {"text": "FastAPI \u2013 Python Web Framework \n \n107 \n \nOutput \nIt will produce the following output: \nuvicorn main:app --reload \n \nINFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C \nto quit) \nINFO: Started reloader process [28720] \nINFO: Started server process [28722] \nINFO: Waiting for application startup. \nServer started: 2021-11-23 23:51:45.907691 \nINFO: Application startup complete. \nINFO: Shutting down \nINFO: Waiting for application \nserver Shutdown: 2021-11-23 23:51:50.82955 \nINFO: Applicatio", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 112}}, {"text": "ng down \nINFO: Waiting for application \nserver Shutdown: 2021-11-23 23:51:50.82955 \nINFO: Application shutdown com \nINFO: Finished server process ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 112}}, {"text": "FastAPI \u2013 Python Web Framework \n \n108 \n \nIf you have two independent FastAPI apps, one of them can be mounted on \ntop of the other. The one that is mounted is called a sub -application. The \napp.mount() method adds another completely \"independent\" application \nin a specific path of the main app. It then takes care of handling everything \nunder that path, with the path operations declared in that sub-application. \nLet us first declare a simple FastAPI application object to be used as a top \nlevel", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 113}}, {"text": "ub-application. \nLet us first declare a simple FastAPI application object to be used as a top \nlevel application. \nfrom fastapi import FastAPI \n \napp = FastAPI() \n \n@app.get(\"/app\") \ndef mainindex(): \n    return {\"message\": \"Hello World from Top level app\"} \nThen create another application object subapp and add its own path \noperations. \nsubapp = FastAPI() \n \n@subapp.get(\"/sub\") \ndef subindex(): \n    return {\"message\": \"Hello World from sub app\"} \nMount this subapp object on the main app by usin", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 113}}, {"text": "    return {\"message\": \"Hello World from sub app\"} \nMount this subapp object on the main app by using mount() method. Two \nparameters needed are the URL route and name of the sub application. \napp.mount(\"/subapp\", subapp) \nBoth the main and sub application will have its own docs as can be inspected \nusing Swagger UI. \n30. FastAPI \u2013 Mounting a Sub-App ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 113}}, {"text": "FastAPI \u2013 Python Web Framework \n \n109 \n \n \nThe sub application\u2019s docs are available at \nhttp://localhost:8000/subapp/docs \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 114}}, {"text": "FastAPI \u2013 Python Web Framework \n \n110 \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 115}}, {"text": "FastAPI \u2013 Python Web Framework \n \n111 \n \nA middleware is a function that is processed with every request (before \nbeing processed by any specific path operation) as well as with every \nresponse before returning it.  This function takes each request that comes \nto your application.  It may perform some process with the request by \nrunning a code defined in it and then passes the request to be processed \nby the corresponding operation function. It can also process the response \ngenerated by the op", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 116}}, {"text": "ssed \nby the corresponding operation function. It can also process the response \ngenerated by the operation function before returning it. \nFollowing are some of the middleware available in FastAPI library: \n\uf0b7 CORSMiddleware \n\uf0b7 HTTPSRedirectMiddleware \n\uf0b7 TrustedHostMiddleware \n\uf0b7 GZipMiddleware \nFastAPI provides app.add_middleware() function to handle server errors \nand custom exception handlers. In addition to the above integrated \nmiddleware, it is possible to define a custom middleware. The fol", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 116}}, {"text": " addition to the above integrated \nmiddleware, it is possible to define a custom middleware. The following \nexample defines the addmiddleware() function and decorates it into a \nmiddleware by decorating it with @app.middleware() decorator. \nThe function has two parameters,  the HTTP request object, and the \ncall_next() function that will send the API request to its corresponding \npath and return a response. \nIn addition to the middleware function, the application also has two \noperation function", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 116}}, {"text": " response. \nIn addition to the middleware function, the application also has two \noperation functions. \nimport time \nfrom fastapi import FastAPI, Request \n \napp = FastAPI() \n \n@app.middleware(\"http\") \nasync def addmiddleware(request: Request, call_next): \n    print(\"Middleware works!\") \n31. FastAPI \u2013 Middleware ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 116}}, {"text": "FastAPI \u2013 Python Web Framework \n \n112 \n \n    response = await call_next(request) \n    return response \n@app.get(\"/\") \nasync def index(): \n    return {\"message\":\"Hello World\"} \n \n@app.get(\"/{name}\") \nasync def hello(name:str): \n    return {\"message\":\"Hello \"+name} \nAs the application runs, for each request made by the browser, the \nmiddleware output (Middleware works!) will appear in the console log before \nthe response output. \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 117}}, {"text": "g before \nthe response output. \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 117}}, {"text": "FastAPI \u2013 Python Web Framework \n \n113 \n \nA WSGI application written in Flask or Django framework can be wrapped \nin WSGIMiddleware and mounted it on a FastAPI app to make it ASGI \ncompliant. \nFirst install the Flask package in the current FastAPI environment. \npip3 install flask \nThe following code is a minimal Flask application: \nfrom flask import Flask \nflask_app = Flask(__name__) \n \n@flask_app.route(\"/\") \ndef index_flask(): \n    return \"Hello World from Flask!\" \nThen declare app as a FastAPI ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 118}}, {"text": "route(\"/\") \ndef index_flask(): \n    return \"Hello World from Flask!\" \nThen declare app as a FastAPI application object and define an operation \nfunction for rendering Hello World message. \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.get(\"/\") \ndef index(): \n    return {\"message\": \"Hello World from FastAPI!\"} \nNext, mount the flask application as a sub application of FastAPI ma in app \nusing mount() method. \nfrom fastapi.middleware.wsgi import WSGIMiddleware \napp.mount(\"/flask\", WSGIMiddl", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 118}}, {"text": "g mount() method. \nfrom fastapi.middleware.wsgi import WSGIMiddleware \napp.mount(\"/flask\", WSGIMiddleware(flask_app)) \n32. FastAPI \u2013 Mounting Flask App ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 118}}, {"text": "FastAPI \u2013 Python Web Framework \n \n114 \n \nRun the Uvicorn development server. \nuvicorn flaskapp:app \u2013reload \nThe main FastAPI application is available at the URL http://localhost:8000/ \nroute. \n{\"message\":\"Hello World from FastAPI!\"} \nThe Flask sub application is mounted at the URL \nhttp://localhost:8000/flask. \nHello World from Flask! \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 119}}, {"text": "FastAPI \u2013 Python Web Framework \n \n115 \n \nSo far, we have been using a local development server \"Uvicorn\" to run our \nFastAPI application. In order to make the application publicly available, it \nmust be deployed on a remote server with a static IP address. It can be \ndeployed to different p latforms such as Heroku, Google Cloud, nginx, etc. \nusing either free plans or subscription based services. \nIn this chapter, we are going to use Deta cloud platform. Its free to use \ndeployment service is ve", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 120}}, {"text": "\nIn this chapter, we are going to use Deta cloud platform. Its free to use \ndeployment service is very easy to use.  \nFirst of all, to use Deta, we need to create an account on its website with a \nsuitable username and password of choice. \n \n33. FastAPI \u2013 Deployment ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 120}}, {"text": "FastAPI \u2013 Python Web Framework \n \n116 \n \nOnce the account is created, install Deta CLI (command line interface) on \nthe local machine. Create a folder for your application (c:\\fastapi_deta_app) \nIf you are using Linux, use the following command in the terminal: \niwr https://get.deta.dev/cli.ps1 -useb | iex \nIf you are using Windows, run the following command from Windows \nPowerShell terminal: \nPS C:\\fastapi_deta_app> iwr https://get.deta.dev/cli.ps1 -useb \n| iex \nDeta was installed successfully ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 121}}, {"text": "C:\\fastapi_deta_app> iwr https://get.deta.dev/cli.ps1 -useb \n| iex \nDeta was installed successfully to \nC:\\Users\\User\\.deta\\bin\\deta.exe \nRun 'deta --help' to get started \nUse the login command and authenticate your username and password. \nPS C:\\fastapi_deta_app> deta login \nPlease, log in from the web page. Waiting... \nhttps://web.deta.sh/cli/60836 \nLogged in successfully. \nIn the same application folder, create a minimal FastAPI application in \nmain.py file \n# main.py \nfrom fastapi import Fast", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 121}}, {"text": "n folder, create a minimal FastAPI application in \nmain.py file \n# main.py \nfrom fastapi import FastAPI \n \napp = FastAPI() \n \n@app.get(\"/\") \ndef read_root(): \n    return {\"Hello\": \"World\"} \n \n@app.get(\"/items/{item_id}\") \ndef read_item(item_id: int): \n    return {\"item_id\": item_id} ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 121}}, {"text": "FastAPI \u2013 Python Web Framework \n \n117 \n \nNow we are ready to deploy our application. Use deta new command from \nthe power shell terminal. \nPS C:\\fastapi_deta_app> deta new \nSuccessfully created a new micro \n{ \n        \"name\": \"fastapi_deta_app\", \n        \"id\": \"2b236e8f-da6a-409b-8d51-7c3952157d3c\", \n        \"project\": \"c03xflte\", \n        \"runtime\": \"python3.9\", \n        \"endpoint\": \"https://vfrjgd.deta.dev\", \n        \"region\": \"ap-southeast-1\", \n        \"visor\": \"enabled\", \n        \"http_auth\"", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 122}}, {"text": "gd.deta.dev\", \n        \"region\": \"ap-southeast-1\", \n        \"visor\": \"enabled\", \n        \"http_auth\": \"disabled\" \n} \nAdding dependencies... \n\u2026.. \nInstalling collected packages: typing-extensions, pydantic, \nidna, sniffio, anyio, starlette, fastapi \nSuccessfully installed anyio-3.4.0 fastapi-0.70.0 idna-3.3 \npydantic-1.8.2 sniffio-1.2.0 starlette-0.16.0 typing-\nextensions-4.0.0 \nDeta deploys the application at the given endpoint (which may be randomly \ncreated for each application). It first inst", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 122}}, {"text": "plication at the given endpoint (which may be randomly \ncreated for each application). It first installs the required dependencies as \nif it is installed on the local machine. After successful deployment, open the \nbrowser and visit the URL as shown in front of endpoint key. The Swagger \nUI documentation can also be found at https://vfrigd.deta.dev/docs. ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 122}}, {"text": "FastAPI \u2013 Python Web Framework \n \n118 \n \n \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 123}}, {"text": " \n \n  ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 1}}, {"text": "FastAPI \u2013 Python Web Framework \n \ni \n \n \nAbout the T utorial \nFastAPI is a modern Python web framework, very efficient in building APIs. \nFastAPI has been developed by Sebastian Ramirez in Dec. 2018. FastAPI \n0.68.0 is the currently available version. The latest version requires Python \n3.6 or above. It is one of the fastest web frameworks of Python. \nAudience \nThis tutorial is designed for developers who want to learn how to build REST \nAPIs using Python.  \nPrerequisites \nBefore you proceed, ma", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 2}}, {"text": "pers who want to learn how to build REST \nAPIs using Python.  \nPrerequisites \nBefore you proceed, make sure that you understand the basics of procedural \nand object -oriented programming in Python. Knowledge of REST \narchitecture is an added advantage. \nDisclaimer & Copyright \n\uf0e3 Copyright 2022 by Tutorials Point (I) Pvt. Ltd.  \nAll the conte nt and graphics published in this e -book are the property of \nTutorials Point (I) Pvt. Ltd. The user of this e -book is prohibited to reuse, \nretain, copy,", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 2}}, {"text": "ty of \nTutorials Point (I) Pvt. Ltd. The user of this e -book is prohibited to reuse, \nretain, copy, distribute or republish any contents or a part of contents of \nthis e-book in any manner without written consent of the publisher.   \nWe strive to update the contents of our website and tutorials as timely and \nas precisely as possible, however, the contents may contain inaccuracies or \nerrors. Tutorials Point (I) Pvt. Ltd. provides no guarantee regarding the \naccuracy, timeliness or completeness", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 2}}, {"text": "orials Point (I) Pvt. Ltd. provides no guarantee regarding the \naccuracy, timeliness or completeness of our website or its contents \nincluding this tutorial. If you discover any errors on our website or in this \ntutorial, please notify us at contact@tutorialspoint.com. \n \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 2}}, {"text": "FastAPI \u2013 Python Web Framework \n \nii \n \nT able of Contents \nAbout the Tutorial ........................................................................................................ i \nAudience ...................................................................................................................... i \nPrerequisites ................................................................................................................ i \nDisclaimer & Copyright .............................", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 3}}, {"text": "............................................ i \nDisclaimer & Copyright ................................................................................................. i \nTable of Contents ........................................................................................................ ii \n1. FASTAPI \u2013 INTRODUCTION ................................ ................................ ..........1 \nFastAPI \u2013 Environment Setup ....................................................................", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 3}}, {"text": ".1 \nFastAPI \u2013 Environment Setup ...................................................................................... 1 \n2. FASTAPI \u2013 HELLO WORLD ................................ ................................ ............3 \nGetting Started ............................................................................................................ 3 \n3. FASTAPI \u2013 OPENAPI ................................ ................................ .....................5 \n4. FASTAPI \u2013 UVICORN.............", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 3}}, {"text": "......... ................................ .....................5 \n4. FASTAPI \u2013 UVICORN................................ ................................ .....................9 \n5. FASTAPI \u2013 TYPE HINTS ................................ ................................ ...............12 \n6. FASTAPI \u2013 IDE SUPPORT ................................ ................................ ............16 \n7. FASTAPI \u2013 REST ARCHITECTURE ................................ ................................ .19 \n8. FA", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 3}}, {"text": "API \u2013 REST ARCHITECTURE ................................ ................................ .19 \n8. FASTAPI \u2013 PATH PARAMETERS ................................ ................................ ...20 \nCheck OpenAPI docs .................................................................................................. 22 \nPath Parameters with Types...................................................................................... 25 \n9. FASTAPI \u2013 QUERY PARAMETERS ................................ .", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 3}}, {"text": "............................... 25 \n9. FASTAPI \u2013 QUERY PARAMETERS ................................ ................................ 27 \n10. FASTAPI \u2013 PARAMETER VALIDATION ................................ ......................... 31 ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 3}}, {"text": "FastAPI \u2013 Python Web Framework \n \niii \n \n11. FASTAPI \u2013 PYDANTIC................................ ................................ ..................37 \n12. FASTAPI \u2013 REQUEST BODY ................................ ................................ .........40 \n13. FASTAPI \u2013 TEMPLATES ................................ ................................ ...............47 \n14. FASTAPI \u2013 STATIC FILES ................................ ................................ ..............52 \n15. FASTAPI \u2013 HTML FORM", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 4}}, {"text": "......................... ................................ ..............52 \n15. FASTAPI \u2013 HTML FORM TEMPLATES ................................ .......................... 56 \n16. FASTAPI \u2013 ACCESSING FORM DATA ................................ ........................... 58 \n17. FASTAPI \u2013 UPLOADING FILES ................................ ................................ .....60 \n18. FASTAPI \u2013 COOKIE PARAMETERS ................................ ............................... 62 \n19. FASTAPI \u2013 HEADER", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 4}}, {"text": "PARAMETERS ................................ ............................... 62 \n19. FASTAPI \u2013 HEADER PARAMETERS ................................ .............................. 65 \n20. FASTAPI \u2013 RESPONSE MODEL ................................ ................................ ....68 \n21. FASTAPI \u2013 NESTED MODELS ................................ ................................ ......71 \n22. FASTAPI \u2013 DEPENDENCIES ................................ ................................ .........75 \n23. FAS", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 4}}, {"text": " DEPENDENCIES ................................ ................................ .........75 \n23. FASTAPI \u2013 CORS ................................ ................................ ......................... 78 \n24. FASTAPI \u2013 CRUD OPERATIONS ................................ ................................ ...80 \n25. FASTAPI \u2013 SQL DATABASES ................................ ................................ ........88 \n26. FASTAPI \u2013 USING MONGODB ................................ ......................", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 4}}, {"text": ".... ........88 \n26. FASTAPI \u2013 USING MONGODB ................................ ................................ ....94 \n27. FASTAPI \u2013 USING GRAPHQL ................................ ................................ .......99 \n28. FASTAPI \u2013 WEBSOCKETS ................................ ................................ .......... 102 ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 4}}, {"text": "FastAPI \u2013 Python Web Framework \n \niv \n \n29. FASTAPI \u2013 FASTAPI EVENT HANDLERS ................................ ..................... 106 \n30. FASTAPI \u2013 MOUNTING A SUB-APP ................................ ...........................  108 \n31. FASTAPI \u2013 MIDDLEWARE ................................ ................................ ......... 111 \n32. FASTAPI \u2013 MOUNTING FLASK APP ................................ ...........................  113 \n33. FASTAPI \u2013 DEPLOYMENT ................................", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 5}}, {"text": "........ ...........................  113 \n33. FASTAPI \u2013 DEPLOYMENT ................................ ................................ ......... 115 ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 5}}, {"text": "FastAPI \u2013 Python Web Framework \n \n1 \n \nFastAPI is a modern Python web framework, very efficient in building APIs. \nIt is based on Python\u2019s type hints feature that has been added since Python \n3.6 onwards. It is one of the fastest web frameworks of Python.  \n\uf0b7 As it works on the functionality of Starlette and Pydantic libraries, its \nperformance is amongst the best and on par with that of NodeJS and \nGo.  \n \n\uf0b7 In addition to offering high performance, FastAPI offers significant \nspeed for develop", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 6}}, {"text": "d \nGo.  \n \n\uf0b7 In addition to offering high performance, FastAPI offers significant \nspeed for development, reduces human-induced errors in the code, \nis easy to learn and is completely production-ready.  \n \n\uf0b7 FastAPI is fully compatible with well -known standards of APIs, \nnamely OpenAPI and JSON schema. \nFastAPI has been developed by Sebastian Ramirez in Dec. 2018. FastAPI \n0.68.0 is the currently available version. \nFastAPI \u2013 Environment Setup \nTo install FastAPI (preferably in a virtual enviro", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 6}}, {"text": " available version. \nFastAPI \u2013 Environment Setup \nTo install FastAPI (preferably in a virtual environment), use pip installer. \npip3 install fastapi \nFastAPI depends on Starlette and Pydantic libraries, hence they also get \ninstalled.  \nInstalling Uvicorn using PIP \nFastAPI doesn\u2019t come with any built -in server application. To run FastAPI \napp, you need an ASGI server called uvicorn, so install the same too, using \npip installer. It will also install uvicorn\u2019s dependencies - asgiref, click, h11", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 6}}, {"text": "he same too, using \npip installer. It will also install uvicorn\u2019s dependencies - asgiref, click, h11, \nand typing-extensions \npip3 install uvicorn \nWith these two libraries installed, we can check all the libraries installed so \nfar. \n1. FastAPI \u2013 Introduction ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 6}}, {"text": "FastAPI \u2013 Python Web Framework \n \n2 \n \npip3 freeze \n \nasgiref==3.4.1 \nclick==8.0.1 \ncolorama==0.4.4 \nfastapi==0.68.0 \nh11==0.12.0 \nimportlib-metadata==4.6.4 \npydantic==1.8.2 \nstarlette==0.14.2 \ntyping-extensions==3.10.0.0 \nuvicorn==0.15.0 \nzipp==3.5.0 \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 7}}, {"text": "FastAPI \u2013 Python Web Framework \n \n3 \n \nGetting Started \nThe first step in creating a FastAPI app is to declare the application object \nof FastAPI class. \nfrom fastapi import FastAPI \napp = FastAPI() \nThis app object is the main point of interaction of the application with the \nclient browser. The uvicorn server uses this object to listen to client\u2019s \nrequest. \nThe next step is to create path operation. Path is a URL which when visited \nby the client invokes visits  a mapped URL to one of the HTT", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 8}}, {"text": "tion. Path is a URL which when visited \nby the client invokes visits  a mapped URL to one of the HTTP methods, an \nassociated function is to be executed.  We need to bind a view function to \na URL and the corresponding HTTP method. For example, the index() \nfunction corresponds to \u2018/\u2019 path with \u2018get\u2019 operation. \n@app.get(\"/\") \nasync def root(): \n    return {\"message\": \"Hello World\"} \nThe function returns a JSON response, however, it can return dict, list, \nstr, int, etc. It can also return Pydan", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 8}}, {"text": "returns a JSON response, however, it can return dict, list, \nstr, int, etc. It can also return Pydantic models. \nSave the following code as main.py \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.get(\"/\") \nasync def index(): \n    return {\"message\": \"Hello World\"} \n2. FastAPI \u2013 Hello World ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 8}}, {"text": "FastAPI \u2013 Python Web Framework \n \n4 \n \nStart the uvicorn server by mentioning the file in which the FastAPI \napplication object is instantiated. \nuvicorn main:app --reload \n \nINFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C \nto quit) \nINFO: Started reloader process [28720] \nINFO: Started server process [28722] \nINFO: Waiting for application startup. \nINFO: Application startup complete. \nOpen the browser and visit http://localhost:/8000. You will see the JSON \nresponse in the browser ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 9}}, {"text": " \nOpen the browser and visit http://localhost:/8000. You will see the JSON \nresponse in the browser window. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 9}}, {"text": "FastAPI \u2013 Python Web Framework \n \n5 \n \nEnter the following URL in the browser to generate automatically the \ninteractive documentation.  \nhttp://127.0.0.1:8000/docs \nFastAPI uses Swagger UI to produce  this documentation. The browser will \ndisplay the following: \n \n3. FastAPI \u2013 OpenAPI ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 10}}, {"text": "FastAPI \u2013 Python Web Framework \n \n6 \n \nClick the 'try it out' button and then ' Execute' button that appears \nafterward. \n \nYou can see the Curl command internally executed, the request URL, the \nresponse headers, and the JSON format of the server\u2019s response. \nFastAPI generates a schema using OpenAPI specifications. The \nspecification determines how to define API paths, path parameters, etc. The \nAPI schema defined by the OpenAPI standard decides how the data is sent \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 11}}, {"text": "API schema defined by the OpenAPI standard decides how the data is sent \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 11}}, {"text": "FastAPI \u2013 Python Web Framework \n \n7 \n \nusing JSON Schema.  Visit http://127.0.0.1:8000/openapi.json from your \nbrowser. A neatly formatted JSON response as follows will be displayed: \n{ \n  \"openapi\": \"3.0.2\", \n  \"info\": { \n    \"title\": \"FastAPI\", \n    \"version\": \"0.1.0\" \n  }, \n  \"paths\": { \n    \"/\": { \n      \"get\": { \n        \"summary\": \"Index\", \n        \"operationId\": \"index__get\", \n        \"responses\": { \n          \"200\": { \n            \"description\": \"Successful Response\", \n            \"conte", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 12}}, {"text": "onses\": { \n          \"200\": { \n            \"description\": \"Successful Response\", \n            \"content\": { \n              \"application/json\": { \n                \"schema\": {} \n              } \n            } \n          } \n        } \n      } \n    } \n  } \n} \nFastAPI also supports another automatic documentation method provided \nby Redoc (https://github.com/Redocly/redoc).  ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 12}}, {"text": "FastAPI \u2013 Python Web Framework \n \n8 \n \nEnter http://localhost:8000/redoc as URL in the browser\u2019s address bar. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 13}}, {"text": "FastAPI \u2013 Python Web Framework \n \n9 \n \nUnlike the Flask framework, FastAPI doesn\u2019t contain any built -in \ndevelopment server. Hence we need Uvicorn. It implements ASGI \nstandards and is lightning fast. ASGI stands for Asynchronous Server \nGateway Interface.  \nThe WSGI (Web Server Gateway Interface \u2013 the older standard) compliant \nweb servers are not suitable for asyncio applications. Python web \nframeworks (such as FastAPI) implementing ASGI specifications provide \nhigh speed performance, compar", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 14}}, {"text": "rameworks (such as FastAPI) implementing ASGI specifications provide \nhigh speed performance, comparable to web apps built with Node and Go. \nUvicorn uses uvloop and httptools libraries. It also provides support for \nHTTP/2 and WebSockets, which cannot be handled by WSGI. uvloop id \nsimilar to the built -in asyncio event loop. httptools library handles the \nhttp protocols. \nThe installation of Uvicorn as described ear lier will install it with minimal \ndependencies. However, standard installatio", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 14}}, {"text": "corn as described ear lier will install it with minimal \ndependencies. However, standard installation will also install cython based \ndependencies along with other additional libraries. \npip3 install uvicorn(standard) \nWith this, the WebSockets protocol will be supported. Also, PyYAML will \nbe installed to allow you to provide a .yaml file. \nAs mentioned earlier, the application is launched on the Uvicorn server with \nthe following command: \nuvicorn main:app \u2013reload \nThe --reload option enables ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 14}}, {"text": " Uvicorn server with \nthe following command: \nuvicorn main:app \u2013reload \nThe --reload option enables the debug mode so that any changes in app.py \nwill be automatically reflected and the display on the client browser will be \nautomatically refreshed. In addition, the following command -line options \nmay be used: \n--host TEXT                      Bind socket to this host.  [default 127.0.0.1] \n--port INTEGER                   Bind socket to this port.  [default 8000] \n--uds TEXT                   ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 14}}, {"text": "t INTEGER                   Bind socket to this port.  [default 8000] \n--uds TEXT                       Bind to a UNIX domain socket. \n--fd INTEGER                     Bind to socket from this file descriptor. \n--reload                         Enable auto-reload. \n4. FastAPI \u2013 Uvicorn ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 14}}, {"text": "FastAPI \u2013 Python Web Framework \n \n10 \n \n--reload-dir PATH                Set reload directories explicitly, default \ncurrent working directory. \n--reload-include TEXT            Include files while watching. Includes '*.py' by \ndefault \n-reload-exclude TEXT            Exclude while watching for files.  \n--reload-delay FLOAT             Delay between previous and next check default \n0.25 \n-loop \n[auto|asyncio|uvloop]   Event loop implementation.  [default auto] \n--http \n[auto|h11|httptools]      ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 15}}, {"text": "uto|asyncio|uvloop]   Event loop implementation.  [default auto] \n--http \n[auto|h11|httptools]      HTTP protocol implementation.  [default auto] \n--interface \nauto|asgi|asgi|wsgi  Select application interface.  [default auto] \n--env-file PATH                  Environment configuration file. \n--log-config PATH                Logging configuration file. Supported formats \n.ini, .json, .yaml. \n--version                        Display the uvicorn version and exit. \n--app-dir TEXT                   ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 15}}, {"text": "sion                        Display the uvicorn version and exit. \n--app-dir TEXT                   Look for APP in the specified directory default \ncurrent directory \n--help                           Show this message and exit. \n \nInstead of starting Uvicorn server from command line, it can be launched \nprogrammatically also.  \nExample \nIn the Python code, call uvicorn.run() method, using any of the \nparameters listed above: \nimport uvicorn \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 15}}, {"text": "the \nparameters listed above: \nimport uvicorn \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.get(\"/\") ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 15}}, {"text": "FastAPI \u2013 Python Web Framework \n \n11 \n \nasync def index(): \n    return {\"message\": \"Hello World\"} \n \nif __name__ == \"__main__\": \n    uvicorn.run(\"main:app\", host=\"127.0.0.1\", port=8000, reload=True) \nNow run this app.py as Python script as follows: \n(fastapienv) C:\\fastapienv>python app.py \nUvicorn server will thus be launched in debug mode. \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 16}}, {"text": "FastAPI \u2013 Python Web Framework \n \n12 \n \nFastAPI makes extensive use of the Type hinting feature made available in \nPython\u2019s version 3.5 onwards. As a matter of fact, Python is known to be a \ndynamically typed language. It also happens to be Python\u2019s distinct feature. \nIn a Python code, a variable need not be declared to be belonging to a \ncertain type, and its type is determined dynamically by the instantaneous \nvalue assigned to it. Python\u2019s interpreter doesn\u2019t perform type checks and \nhence it", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 17}}, {"text": " instantaneous \nvalue assigned to it. Python\u2019s interpreter doesn\u2019t perform type checks and \nhence it is prone to runtime exceptions. \nIn the following example, a division() function is defined with two \nparameters and returns their division, assuming that the parameters will be \nnumeric. \n>>> def division(a, b): \n return a/b \n>>> division(10, 4) \n2.5 \n \n>>> division(10, 2.5) \n4.0 \nHowever, if one of the values passed to the function happen to be non -\nnumeric, it results in TypeError as shown be", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 17}}, {"text": "of the values passed to the function happen to be non -\nnumeric, it results in TypeError as shown below: \n>>> division(\"Python\",5) \n \nTypeError: unsupported operand type(s) for /: 'str' and 'int' \nEven a basic coding environment such as IDLE indicates that the function \nrequires two parameters but won\u2019t specify the types as they haven\u2019t been \ndeclared. \n5. FastAPI \u2013 Type Hints ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 17}}, {"text": "FastAPI \u2013 Python Web Framework \n \n13 \n \n \nPython\u2019s new type hinting feature helps in prom pting the user with the \nexpected type of the parameters to be passed. This is done by adding a \ncolon and data type after the parameter. We\u2019ll redefine the division() \nfunction as follows: \n \nNote that while calling the function, Python hints at the expected type of \neach parameter to be passed. However, this doesn\u2019t prevent the TypeError \nfrom appearing if an incompatible value is passed. You will have to", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 18}}, {"text": "s doesn\u2019t prevent the TypeError \nfrom appearing if an incompatible value is passed. You will have to use a \nstatic type checker such as MyPy to check for compatibility before running.  \nJust as the formal parameters in the function\u2019s definition, it is possible to \nprovide type hint for a function\u2019s return value. Just before the colon symbol \nin the function\u2019s definition statement (after which the function block starts) \nadd an arrow (->) and the type. \n \nHowever, as mentioned earlier, if incompa", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 18}}, {"text": "function block starts) \nadd an arrow (->) and the type. \n \nHowever, as mentioned earlier, if incompatible values are passed to the \nfunction, or returned by the function, Python reports TypeError. Use of MyPy \nstatic type checker can detect such errors. Install mypy package first. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 18}}, {"text": "FastAPI \u2013 Python Web Framework \n \n14 \n \npip3 install mypy \nSave the following code as typecheck.py \ndef division(x:int, y:int) -> int: \n return (x//y) \n \na=division(10,2) \nprint (a) \n \nb=division(5,2.5) \nprint (b) \n \nc=division(\"Hello\",10) \nprint (c) \nCheck this code for type errors using mypy. \nC:\\python37>mypy typechk.py \ntypechk.py:7: error: Argument 2 to \"division\" has incompatible \ntype \"float\"; expected \"int\" \ntypechk.py:10: error: Argument 1 to \"division\" has \nincompatible type \"str\"; exp", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 19}}, {"text": "t\"; expected \"int\" \ntypechk.py:10: error: Argument 1 to \"division\" has \nincompatible type \"str\"; expected \"int\" \nFound 2 errors in 1 file (checked 1 source file) \nThere are errors in second and third calls to the function. In second, value \npassed to y is float when int is expected. In third, value passed to x is str \nwhen int is expected. (Note that // operator returns integer division) \nAll standard d ata types can be used as type hints. This can be done with \nglobal variables, variables as fu", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 19}}, {"text": "dard d ata types can be used as type hints. This can be done with \nglobal variables, variables as function parameters, inside function definition \netc. \nx: int = 3 \ny: float = 3.14 ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 19}}, {"text": "FastAPI \u2013 Python Web Framework \n \n15 \n \nnm: str = 'abc' \nmarried: bool = False \nnames: list = ['a', 'b', 'c'] \nmarks: tuple = (10, 20, 30) \nmarklist: dict = {'a': 10, 'b': 20, 'c': 30} \nA new addition in newer versions of Python (version 3.5 onwards) standard \nlibrary is the typing module. It defines special types for corresponding \nstandard collection types. The types on typing module are List, Tuple, \nDict, and Sequence. It also consists of Union and Optional types. Note \nthat standard names o", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 20}}, {"text": "uple, \nDict, and Sequence. It also consists of Union and Optional types. Note \nthat standard names of data types are all in small case, whereas ones in \ntyping module have first letter in upper case. Using this feature, we can ask \na collection of a particular type. \nfrom typing import List, Tuple, Dict \n \n# following line declares a List object of strings.  \n# If violated, mypy shows error \ncities: List[str] = ['Mumbai', 'Delhi', 'Chennai'] \n \n# This is Tuple with three elements respectively  \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 20}}, {"text": "s: List[str] = ['Mumbai', 'Delhi', 'Chennai'] \n \n# This is Tuple with three elements respectively  \n# of str, int and float type) \nemployee: Tuple[str, int, float] = ('Ravi', 25, 35000) \n \n# Similarly in the following Dict, the object key should be str \n# and value should be of int type, failing which  \n# static type checker throws error \nmarklist: Dict[str, int] = {'Ravi': 61, 'Anil': 72} ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 20}}, {"text": "FastAPI \u2013 Python Web Framework \n \n16 \n \nThe Type Hinting feature of Python is most effectively used in almost all \nIDEs (Integrated Development Environments) such as PyCharm and VS \nCode to provide dynamic autocomplete features. \nLet us see how VS Code  uses the type hints to provide autocomplete \nsuggestions while writing a code. In the example below, a function named \nas sayhello with name as an argument has been defined. The function \nreturns a string by concatenating \u201cHello\u201d to the name para", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 21}}, {"text": " argument has been defined. The function \nreturns a string by concatenating \u201cHello\u201d to the name parameter by adding \na space in between. Additionally, it is required to ensure that the first letter \nof the name be in upper case.  \nPython\u2019s str class has a capitalize() method for the purpose, but if one \ndoesn\u2019t remember it while typing the code, one has to search for it  \nelsewhere. If you give a dot after name, you expect the list of attributes but \nnothing is shown because Python doesn\u2019t know ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 21}}, {"text": "dot after name, you expect the list of attributes but \nnothing is shown because Python doesn\u2019t know what will be the runtime \ntype of name variable. \n \nHere, type hint comes handy. Include str as the type of name in the \nfunction definition. Now when you press dot (.) after name, a drop down \nlist of all string methods appears, from which the required method (in this \ncase capitalize()) can be picked. \n6. FastAPI \u2013 IDE Support ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 21}}, {"text": "ked. \n6. FastAPI \u2013 IDE Support ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 21}}, {"text": "FastAPI \u2013 Python Web Framework \n \n17 \n \n \nIt is also possible to use type hints with a user defined class. In the following \nexample a rectangle class is defined with type hints for arguments to the  \n__init__() constructor. \nclass rectangle: \n    def __init__(self, w:int, h:int) ->None: \n        self.width=w \n        self.height=h \nFollowing is a function that uses an object of above rec tangle class as an \nargument. The type hint used in the declaration is the name of the class. \ndef area(r:re", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 22}}, {"text": "lass as an \nargument. The type hint used in the declaration is the name of the class. \ndef area(r:rectangle)->int: \n    return r.width*r.height \n \nr1=rectangle(10,20) \nprint (\"area = \", area(r1)) \nIn this case also, the IDE editor provides autocomplete su pport prompting \nlist of the instance attributes. Following is a screenshot of PyCharm editor.  \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 22}}, {"text": "FastAPI \u2013 Python Web Framework \n \n18 \n \n \nFastAPI makes extensive use of the type hints. This feature is found \neverywhere, such as path parameters, query parameters, headers, bodies, \ndependencies, etc. as well as validating the data from the incoming request. \nThe OpenAPI document generation also uses type hints. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 23}}, {"text": "FastAPI \u2013 Python Web Framework \n \n19 \n \nRElational State Transfer (REST) is a software architectural style. REST \ndefines how the architecture of a web application should behave. It is a \nresource based architecture where everything that the REST server hosts, \n(a file, an image, or a row in a table of a database), is a resource , having \nmany representations.  \nREST recommends certain architectural constraints. \n\uf0b7 Uniform interface \n \n\uf0b7 Statelessness \n \n\uf0b7 Client-server \n \n\uf0b7 Cacheability \n \n\uf0b7 La", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 24}}, {"text": "al constraints. \n\uf0b7 Uniform interface \n \n\uf0b7 Statelessness \n \n\uf0b7 Client-server \n \n\uf0b7 Cacheability \n \n\uf0b7 Layered system \n \n\uf0b7 Code on demand \nREST constraints has the following advantages: \n\uf0b7 Scalability \n \n\uf0b7 Simplicity \n \n\uf0b7 Modifiability \n \n\uf0b7 Reliability \n \n\uf0b7 Portability \n \n\uf0b7 Visibility \n \nREST uses HTTP verbs or methods for the operation on the resources. The \nPOST, GET, PUT and DELETE methods perform respectively CREATE, READ, \nUPDATE and DELETE operations respectively. \n7. FastAPI \u2013 REST Architectur", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 24}}, {"text": "espectively CREATE, READ, \nUPDATE and DELETE operations respectively. \n7. FastAPI \u2013 REST Architecture ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 24}}, {"text": "FastAPI \u2013 Python Web Framework \n \n20 \n \nModern web frameworks use routes or endpoints as a part of URL instead \nof file-based URLs. This helps the user to remember the application URLs \nmore effectively. In FastAPI, it is termed a path. A path or route is the part \nof the URL trailing after the first \u2018/\u2019.  \nFor example, in the following URL,  \nhttp://localhost:8000/hello/TutorialsPoint \nthe path or the route would be \n/hello/TutorialsPoint \nIn FastAPI, such a path string is given as a parameter ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 25}}, {"text": "r the route would be \n/hello/TutorialsPoint \nIn FastAPI, such a path string is given as a parameter to the operation \ndecorator. The operation here refers to the HTTP verb used by the browser \nto send the data. These operations include GET, PUT, etc. The operation \ndecorator (for example, @app.get(\"/\")) is immediately followed by a \nfunction that is executed when the specified URL is visited. In the below \nexample: \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.get(\"/\") \nasync def index()", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 25}}, {"text": "he below \nexample: \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.get(\"/\") \nasync def index(): \n    return {\"message\": \"Hello World\"} \nHere, (\"/\") is the path,  get is the operation, @app.get(\"/\") is the path \noperation decorator, and the index() function just below it is termed as \npath operation function. \nAny of the following HTTP verbs can be used as operations. \nGET Sends data in unencrypted form to the server. Most \ncommon method. \nHEAD Same as GET, but without the response body. \n8", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 25}}, {"text": "rypted form to the server. Most \ncommon method. \nHEAD Same as GET, but without the response body. \n8. FastAPI \u2013 Path Parameters ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 25}}, {"text": "FastAPI \u2013 Python Web Framework \n \n21 \n \nPOST Used to send HTML form data to the server. Data received \nby the POST method is not cached by the server. \nPUT Replaces all current representations of the target resource \nwith the uploaded content. \nDELETE Removes all current representations of the target resource \ngiven by a URL. \n \nThe async keyword in the function\u2019s definition tells FastAPI that it is to be \nrun asynchronously i.e. without blocking the current thread of execution. \nHowever, a path", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 26}}, {"text": "is to be \nrun asynchronously i.e. without blocking the current thread of execution. \nHowever, a path operation function can be defined without the async prefix \nalso. \nThis decorated function returns a JSON response. Although it can return \nalmost any of Python\u2019s objects, it will be automatically converted to JSON. \nFurther in this tutorial, we shall see how such a function returns Pydantic \nmodel objects. \nThe URL\u2019s endpoint or path can have one or more variable parameters. They \ncan be accepte", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 26}}, {"text": " objects. \nThe URL\u2019s endpoint or path can have one or more variable parameters. They \ncan be accepted by using Python\u2019s string formatting notation. In the above \nexample URL http://localhost:8000/hello/TutorialsPoint,  the last value may \nchange in every client request. This variable parameter can be accepted in \na variable as defined in the path and passed to the formal parameters \ndefined in the function bound to the operation decorator. \nExample \nAdd another path decorator with a variable par", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 26}}, {"text": " function bound to the operation decorator. \nExample \nAdd another path decorator with a variable parameter in the route, and bind \nhello() function to have name parameter. Modify the main.py as per the \nfollowing. \nimport uvicorn \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.get(\"/\") \nasync def index(): \n    return {\"message\": \"Hello World\"} \n \n@app.get(\"/hello/{name}\") ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 26}}, {"text": "FastAPI \u2013 Python Web Framework \n \n22 \n \nasync def hello(name): \n    return {\"name\": name} \nStart the Uvicorn server and visit http://localhost:8000/hello/Tutorialspoint \nURL. The browser shows the following JSON response. \n{\"name\":\"Tutorialspoint\"} \nChange the variable path parameter to something else such as \nhttp://localhost:8000/hello/Python so that the browser shows: \n{\"name\":\"Python\"} \nCheck OpenAPI docs \nNow if we c heck the OpenAPI documentation by entering the URL as \nhttp://localhost:80", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 27}}, {"text": "OpenAPI docs \nNow if we c heck the OpenAPI documentation by entering the URL as \nhttp://localhost:8000/docs, it will show two routes and their respective view \nfunctions. Click the try out button below /hello/{name} button and give \nTutorialspoint as the value of the name parameter\u2019s description and then \nclick the Execute button. ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 27}}, {"text": "FastAPI \u2013 Python Web Framework \n \n23 \n \n \nIt will then show the Curl command, the request URL and the details of \nserver\u2019s response with response body and response headers. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 28}}, {"text": "FastAPI \u2013 Python Web Framework \n \n24 \n \n \nA route can have multiple parameters separated by \"/\" symbol.  \nfrom fastapi import FastAPI \napp = FastAPI() \n@app.get(\"/hello/{name}/{age}\") \nasync def hello(name,age): \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 29}}, {"text": "FastAPI \u2013 Python Web Framework \n \n25 \n \n    return {\"name\": name, \"age\":age} \nIn this case, /hello is the route, followed by two parameters put in curly \nbrackets. If the URL given in the browser\u2019s address bar is \nhttp://localhost:8000/hello/Ravi/20, The data of Ravi and 20 will be \nassigned to variables name and age respectively. The browser displays the \nfollowing JSON response: \n{\"name\":\"Ravi\",\"age\":\"20\"} \nPath Parameters with T ypes \nYou can use Python\u2019s type hints for the parameters of the ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 30}}, {"text": "\"age\":\"20\"} \nPath Parameters with T ypes \nYou can use Python\u2019s type hints for the parameters of the function to be \ndecorated. In this case, define name as str and age as int. \n@app.get(\"/hello/{name}/{age}\") \nasync def hello(name:str,age:int): \n    return {\"name\": name, \"age\":age}  \nThis will result in the browser displaying an HTTP error message in the JSON \nresponse if the types don\u2019t match. Try entering \nhttp://localhost:8000/hello/20/Ravi as the URL. The browser\u2019s response will \nbe as follo", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 30}}, {"text": "y entering \nhttp://localhost:8000/hello/20/Ravi as the URL. The browser\u2019s response will \nbe as follows: \n{ \n  \"detail\": [ \n    { \n      \"loc\": [ \n        \"path\", \n        \"age\" \n      ], \n      \"msg\": \"value is not a valid integer\", \n      \"type\": \"type_error.integer\" \n    } \n  ] ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 30}}, {"text": "FastAPI \u2013 Python Web Framework \n \n26 \n \n} \nThe reason is obvious as age being integer, can\u2019t accept a string value. This \nwill also be reflected in the Swagger UI (OpenAPI) documentation. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 31}}, {"text": "FastAPI \u2013 Python Web Framework \n \n27 \n \nA classical method of passing the request data to the server is to append a \nquery string to the URL. Assuming that a Python script (hello.py) on a server \nis executed as CGI, a list of key-value pairs concatenated by the \nampersand (&) forms the query string , which is appended to the URL by \nputting a question mark (?) as a separator. For example: \nhttp://localhost/cgi-bin/hello.py?name=Ravi&age=20  \nThe trailing part of the URL, after (?), is th e query", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 32}}, {"text": "localhost/cgi-bin/hello.py?name=Ravi&age=20  \nThe trailing part of the URL, after (?), is th e query string, which is then \nparsed by the server-side script for further processing. \nAs mentioned, the query string is a list of parameter=value pairs \nconcatenated by & symbol. FastAPI automatically treats the part of the \nendpoint which is not a path parameter as a query string and parses it into \nparameters and its values. These parameters are passed to the function \nbelow the operation decorator.", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 32}}, {"text": "rameters and its values. These parameters are passed to the function \nbelow the operation decorator. \nExample \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.get(\"/hello\") \nasync def hello(name:str,age:int): \n    return {\"name\": name, \"age\":age} \nStart the Uvicorn server and this URL in the browser: \nhttp://localhost:8000/hello?name=Ravi&age=20 \nYou should get the same JSON response. However, checking the t ells you \nthat FastAPI has detected that /hello endpoint has no path parameters, bu", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 32}}, {"text": ", checking the t ells you \nthat FastAPI has detected that /hello endpoint has no path parameters, but \nquery parameters.  \n9. FastAPI \u2013 Query Parameters ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 32}}, {"text": "FastAPI \u2013 Python Web Framework \n \n28 \n \n \nClick the Try it out button, enter \"Ravi\" and \"20\" as values, and press the \nExecute button. The documentation page now shows Curl command, \nrequest URL, and the body and headers of HTTP response. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 33}}, {"text": "FastAPI \u2013 Python Web Framework \n \n29 \n \n \nExample \nYou can use Python\u2019s type hints for the parameters of the function to be \ndecorated. In this case, define name as str and age as int. \nfrom fastapi import FastAPI \napp = FastAPI() \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 34}}, {"text": "FastAPI \u2013 Python Web Framework \n \n30 \n \n@app.get(\"/hello/{name}\") \nasync def hello(name:str,age:int): \n    return {\"name\": name, \"age\":age} \nTry entering http://localhost:8000/docs as the URL. This will open the \nSwagger UI (OpenAPI) documentation. The parameter 'name' is a path \nparameter and 'age' is a query parameter. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 35}}, {"text": "FastAPI \u2013 Python Web Framework \n \n31 \n \nIt is possible to apply validation conditions on path parameters as well \nas query parameters of the URL. In order to apply the validation conditions \non a path parameter, you need to import the Path class. In addition to the \ndefault value of the parameter, you can specify the maximum and minimum \nlength in the case of a string parameter. \nfrom fastapi import FastAPI, Path \napp = FastAPI() \n \n@app.get(\"/hello/{name}\") \nasync def hello(name:str=Path(...,mi", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 36}}, {"text": "rt FastAPI, Path \napp = FastAPI() \n \n@app.get(\"/hello/{name}\") \nasync def hello(name:str=Path(...,min_length=3, \nmax_length=10)): \n    return {\"name\": name} \nIf the browser\u2019s URL contains the parameter with a length less than 3 or \nmore than 10, as in ( http://localhost:8000/hello/Tutorialspoint), there will \nbe an appropriate error message such as: \n{ \n  \"detail\": [ \n    { \n      \"loc\": [ \n        \"path\", \n        \"name\" \n      ], \n      \"msg\": \"ensure this value has at most 10 characters\", \n  ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 36}}, {"text": "  \"path\", \n        \"name\" \n      ], \n      \"msg\": \"ensure this value has at most 10 characters\", \n      \"type\": \"value_error.any_str.max_length\", \n      \"ctx\": { \n        \"limit_value\": 10 \n      } \n10. FastAPI \u2013 Parameter Validation ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 36}}, {"text": "FastAPI \u2013 Python Web Framework \n \n32 \n \n    } \n  ] \n} \nThe OpenAPI docs also shows the validations applied: \n \nValidation rules can be applied on numeric parameters too, using the \noperators as given below: \n\uf0b7 gt: greater than \n\uf0b7 ge: greater than or equal \n\uf0b7 lt: less than \n\uf0b7 le: less than or equal \nLet us modify the  above operation decorator to include age as a path \nparameter and apply the validations. \nfrom fastapi import FastAPI, Path \napp = FastAPI() \n@app.get(\"/hello/{name}/{age}\") \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 37}}, {"text": "ations. \nfrom fastapi import FastAPI, Path \napp = FastAPI() \n@app.get(\"/hello/{name}/{age}\") \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 37}}, {"text": "FastAPI \u2013 Python Web Framework \n \n33 \n \nasync def hello(*, name: str=Path(...,min_length=3 , \nmax_length=10), age: int = Path(..., ge=1, le=100)): \n    return {\"name\": name, \"age\":age} \nIn this case, validation rules are applied for both the parameters name and \nage. If the URL entered is http://localhost:8000/hello/hi/110, then the  \nJSON response shows following explanations for validation failure: \n{ \n  \"detail\": [ \n    { \n      \"loc\": [ \n        \"path\", \n        \"name\" \n      ], \n      \"msg\"", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 38}}, {"text": "re: \n{ \n  \"detail\": [ \n    { \n      \"loc\": [ \n        \"path\", \n        \"name\" \n      ], \n      \"msg\": \"ensure this value has at least 3 characters\", \n      \"type\": \"value_error.any_str.min_length\", \n      \"ctx\": { \n        \"limit_value\": 3 \n      } \n    }, \n    { \n      \"loc\": [ \n        \"path\", \n        \"age\" \n      ], \n      \"msg\": \"ensure this value is less than or equal to 100\", \n      \"type\": \"value_error.number.not_le\", \n      \"ctx\": { \n        \"limit_value\": 100 \n      } ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 38}}, {"text": " \"value_error.number.not_le\", \n      \"ctx\": { \n        \"limit_value\": 100 \n      } ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 38}}, {"text": "FastAPI \u2013 Python Web Framework \n \n34 \n \n    } \n  ] \n} \nThe swagger UI documentation also identifies the constraints. \n \nThe query parameters can also have the validation rules applied to them. \nYou have to specify them as the part of arguments of Query class \nconstructor. \nLet us add a q uery parameter called percent in the above function and \napply the validation rules as ge=0 (i.e., greater then equal to 0) and \nlt=100 (less than or equal to 100) \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 39}}, {"text": " equal to 0) and \nlt=100 (less than or equal to 100) \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 39}}, {"text": "FastAPI \u2013 Python Web Framework \n \n35 \n \nfrom fastapi import FastAPI, Path, Query \n \n@app.get(\"/hello/{name}/{age}\") \nasync def hello(*, name: str=Path(...,min_length=3 , \nmax_length=10), \\ \n                age: int = Path(..., ge=1, le=100), \\ \n                percent:float=Query(..., ge=0, le=100)): \n    return {\"name\": name, \"age\":age} \nIf the URL entered is http://localhost:8000/hello/Ravi/20?percent=79, then \nthe browser displays following JSON response: \n{\"name\":\"Ravi\",\"age\":20} \nFastAPI co", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 40}}, {"text": "ercent=79, then \nthe browser displays following JSON response: \n{\"name\":\"Ravi\",\"age\":20} \nFastAPI correctly identifies percent as a query parameter with validati on \nconditions applied. It is reflected in the OpenAPI documentation as follows: ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 40}}, {"text": "FastAPI \u2013 Python Web Framework \n \n36 \n \n \nWhile the client can send the path and query parameters to the API server \nusing GET method, we need to apply POST method to send some binary \ndata as a part of the HTTP request. This binary data may be in the form of \nan object of any Python class. It forms the request body. FastAPI uses \nPydantic library for this purpose. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 41}}, {"text": "FastAPI \u2013 Python Web Framework \n \n37 \n \nPydantic is a Python library for data parsing and validation. It uses the \ntype hinting me chanism of the newer versions of Python (version 3.6 \nonwards) and validates the types during the runtime. Pydantic defines \nBaseModel class. It acts as the base class for creating user defined models. \nFollowing code defines a Student class as a model based on BaseModel. \nfrom typing import List \nfrom pydantic import BaseModel \n \nclass Student(BaseModel): \n    id: i", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 42}}, {"text": "el. \nfrom typing import List \nfrom pydantic import BaseModel \n \nclass Student(BaseModel): \n    id: int \n    name :str \n    subjects: List[str] = [] \nThe attributes of the Student class are declared with type hints. Note that \nthe subjects attribute is of List type defined in typing module and of built -\nin list type. \nWe can populate an object of Student class with a dictionary with matching \nstructure as follows: \n>>> data = { \n    'id': 1, \n    'name': 'Ravikumar', \n    'subjects': [\"Eng\", \"Ma", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 42}}, {"text": "cture as follows: \n>>> data = { \n    'id': 1, \n    'name': 'Ravikumar', \n    'subjects': [\"Eng\", \"Maths\", \"Sci\"], \n} \n>>> s1=Student(**data) \n>>> print (s1) \nid=1 name='Ravikumar' subjects=['Eng', 'Maths', 'Sci'] \n>>> s1 \nStudent(id=1, name='Ravikumar', subjects=['Eng', 'Maths', 'Sci']) \n11. FastAPI \u2013 Pydantic ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 42}}, {"text": "FastAPI \u2013 Python Web Framework \n \n38 \n \n>>> s1.dict() \n{'id': 1, 'name': 'Ravikumar', 'subjects': ['Eng', 'Maths', 'Sci']} \nPydantic will automatically get the data types converted whenever \npossible. For example, even if the id key in the dictionary is assigned a \nstring representation of a number (such as '123'), it will coerce it into an \ninteger. But whenever not possible, an exception will be raised. \n>>> data = { \n    'id': [1,2], \n    'name': 'Ravikumar', \n    'subjects': [\"Eng\", \"Maths\",", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 43}}, {"text": " raised. \n>>> data = { \n    'id': [1,2], \n    'name': 'Ravikumar', \n    'subjects': [\"Eng\", \"Maths\", \"Sci\"], \n} \n>>> s1=Student(**data) \nTraceback (most recent call last): \n  File \"<pyshell#13>\", line 1, in <module> \n    s1=Student(**data) \n  File \"pydantic\\main.py\", line 406, in \npydantic.main.BaseModel.__init__ \npydantic.error_wrappers.ValidationError: 1 validation error \nfor Student \nid \n  value is not a valid integer (type=type_error.integer) \nPydantic also contains a Field class to declare ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 43}}, {"text": "e is not a valid integer (type=type_error.integer) \nPydantic also contains a Field class to declare metadata and validation rules \nfor the model attributes. First modify the Student class to apply Field type \non \"name\" attribute as follows: \nfrom typing import List \nfrom pydantic import BaseModel, Field \n \nclass Student(BaseModel): \n    id: int \n    name :str = Field(None, title=\"The description of the \nitem\", max_length=10) ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 43}}, {"text": "f the \nitem\", max_length=10) ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 43}}, {"text": "FastAPI \u2013 Python Web Framework \n \n39 \n \n    subjects: List[str] = [] \nPopulate the data as shown below. The name here is exceeding the \nmax_length stipulated. Pydantic throws ValidationError as expected. \n>>> data = { \n    'id': 1, \n    'name': 'Ravikumar Sharma', \n    'subjects': [\"Eng\", \"Maths\", \"Sci\"], \n} \n>>> s1=Student(**data) \nTraceback (most recent call last): \n  File \"<pyshell#28>\", line 1, in <module> \n    s1=Student(**data) \n  File \"pydantic\\main.py\", line 406, in \npydantic.main.BaseMo", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 44}}, {"text": ", in <module> \n    s1=Student(**data) \n  File \"pydantic\\main.py\", line 406, in \npydantic.main.BaseModel.__init__ \npydantic.error_wrappers.ValidationError: 1 validation error \nfor Student \nname \n  ensure this value has at most 10 characters \n(type=value_error.any_str.max_length; limit_value=10) \nPydantic models can be used to map with ORM models like SQLAlchemy \nor Peewee. ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 44}}, {"text": "FastAPI \u2013 Python Web Framework \n \n40 \n \nWe shall now use the Pydantic model object as a request body of the client\u2019s \nrequest. As mentioned earlier, we need to use POST operation decorator for \nthe purpose. \nimport uvicorn \nfrom fastapi import FastAPI \nfrom typing import List \nfrom pydantic import BaseModel, Field \napp = FastAPI() \nclass Student(BaseModel): \n    id: int \n    name :str = Field(None, title=\"name of student\", max_length=10) \n    subjects: List[str] = [] \n \n@app.post(\"/students/\") \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 45}}, {"text": ", title=\"name of student\", max_length=10) \n    subjects: List[str] = [] \n \n@app.post(\"/students/\") \nasync def student_data(s1: Student): \n    return s1 \nAs it can be seen, the student_data() function is decorated by \n@app.post() decorator having the URL endpoint as \"/students/\". It \nreceives an object of Student class as Body parameter from the client\u2019s \nrequest. To test this route, start the Uvicorn server and open the Swagger \nUI documentation in the browser by visiting http://localhost:8000/d", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 45}}, {"text": "orn server and open the Swagger \nUI documentation in the browser by visiting http://localhost:8000/docs \nThe documentation identifies that \"/students/\" route is attached with \nstudent_data() function with POST method.  Under the schemas section \nthe Student model will be listed.  \n12. FastAPI \u2013 Request Body ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 45}}, {"text": "FastAPI \u2013 Python Web Framework \n \n41 \n \n \nExpand the node in front of it to reveal the structure of the model \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 46}}, {"text": "FastAPI \u2013 Python Web Framework \n \n42 \n \n \nClick the Try it out button to fill in the test values in the request body. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 47}}, {"text": "FastAPI \u2013 Python Web Framework \n \n43 \n \n \nClick the Execute button and get the server\u2019s response values. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 48}}, {"text": "FastAPI \u2013 Python Web Framework \n \n44 \n \n \nWhile a Pydantic model automatically populates the request body, it is also \npossible to use singular values to add attributes to it. For that purpose, we \nneed to use Body class objects as the parameters of the operation function \nto be decorated. \nFirst, we need to import Body class from fastapi. As shown in the following \nexample, declare ' name' and 'marks' as the Body parameters in the \ndefinition of student_data() function below the @app.post() dec", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 49}}, {"text": "arks' as the Body parameters in the \ndefinition of student_data() function below the @app.post() decorator. \nimport uvicorn \nfrom fastapi import FastAPI, Body \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 49}}, {"text": "FastAPI \u2013 Python Web Framework \n \n45 \n \n \n@app.post(\"/students\") \nasync def student_data(name:str=Body(...), \nmarks:int=Body(...)): \n    return {\"name\":name,\"marks\": marks} \nIf we check the Swagger UI documentation, we should be able to find this \nPOST method associated to student_data() function and having a request \nbody with two parameters. \n \nIt is also possible to declare an operation function to have path and/or query \nparameters along with request body. Let us modify the student_data() \nf", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 50}}, {"text": "n to have path and/or query \nparameters along with request body. Let us modify the student_data() \nfunction to have a path parameter 'college\u2019, 'age' as query parameter and \na Student model object as body parameter. \n@app.post(\"/students/{college}\") \nasync def student_data(college:str, age:int, student:Student): \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 50}}, {"text": "FastAPI \u2013 Python Web Framework \n \n46 \n \n    retval={\"college\":college, \"age\":age, **student.dict()} \n    return retval \nThe function adds values of college and age parameters along with the \ndictionary representation of Student object and returns it as a response. We \ncan check the API documentation as follows: \n \nAs it can be seen, college is the path parameter, age is a query parameter, \nand the Student model is the request body. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 51}}, {"text": " Student model is the request body. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 51}}, {"text": "FastAPI \u2013 Python Web Framework \n \n47 \n \nBy default, FastAPI renders a JSON response to the client. However, it can \nbe cast to a HTML response. For this purpose, FastAPI has HTMLResponse \nclass defined in fastapi.responses module. We need to add \nresponse_class as an additional parameter to operation decorator, with \nHTMLResponse object as its value. \nIn the following example, the @app.get() decorator has \"/hello/\" endpoint \nand the HTMLRespo nse as response_class. Inside the hello() function, w", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 52}}, {"text": "ator has \"/hello/\" endpoint \nand the HTMLRespo nse as response_class. Inside the hello() function, we \nhave a string representation of a HTML code of Hello World message. The \nstring is returned in the form of HTML response. \nfrom fastapi.responses import HTMLResponse \nfrom fastapi import FastAPI \napp = FastAPI() \n@app.get(\"/hello/\") \nasync def hello(): \n    ret=''' \n<html> \n<body> \n<h2>Hello World!</h2> \n</body> \n</html> \n''' \n    return HTMLResponse(content=ret) \nOn examining the API docs, it ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 52}}, {"text": "d!</h2> \n</body> \n</html> \n''' \n    return HTMLResponse(content=ret) \nOn examining the API docs, it can be seen that the server\u2019s response body \nis in HTML. \n13. FastAPI \u2013 Templates ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 52}}, {"text": "FastAPI \u2013 Python Web Framework \n \n48 \n \n \nThe request URL ( http://localhost:8000/hello/) should also render the \nmessage in the browser. However, rendering a raw HTML response is very \ntedious. Alternately, it is possible to render prebuilt HTML pages as \ntemplates. For that we need to use a web template library. \nWeb template library has a template engine that merges a static web page \nhaving place holder variables. Data from any source such as database  is \nmerged to dynamically generate and ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 53}}, {"text": "ace holder variables. Data from any source such as database  is \nmerged to dynamically generate and render the web page. FastAPI doesn\u2019t \nhave any prepackaged template library. So one is free to use any one that \nsuits his needs. In this tutorial, we shall be using jinja2, a very popular \nweb template library. Let us install it first using pip installer. \npip3 install jinja2 \nFastAPI\u2019s suppor t for Jinja templates comes in the form of \njinja2Templates class defined in fastapi.templates module. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 53}}, {"text": "r Jinja templates comes in the form of \njinja2Templates class defined in fastapi.templates module. \nfrom fastapi.templating import Jinja2Templates \nTo declare a template object, the folder in which the html templates are \nstored, should be provided as para meter. Inside the current working \ndirectory, we shall create a \u2018templates\u2019 directory. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 53}}, {"text": "FastAPI \u2013 Python Web Framework \n \n49 \n \n \ntemplates = Jinja2Templates(directory=\"templates\") \nA simple web page \u2018hello.html\u2019 to render Hello World message is also put \nin \u2018templates\u2019 folder. \n<html> \n<body> \n<h2>Hello World!</h2> \n</body> \n</html> \nWe are now going to render html code from this page as HTMLResponse. \nLet us modify the hello() function as follows: \nfrom fastapi.responses import HTMLResponse \nfrom fastapi.templating import Jinja2Templates \nfrom fastapi import FastAPI, Request \napp", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 54}}, {"text": "LResponse \nfrom fastapi.templating import Jinja2Templates \nfrom fastapi import FastAPI, Request \napp = FastAPI() \ntemplates = Jinja2Templates(directory=\"templates\") \n \n@app.get(\"/hello/\", response_class=HTMLResponse) \nasync def hello(request: Request): \n    return templates.TemplateResponse(\"hello.html\", \n{\"request\": request}) \nHere, templateResponse() method of template object collects the \ntemplate code and the request context to render the http response. When \nwe start the server and visit th", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 54}}, {"text": "ate code and the request context to render the http response. When \nwe start the server and visit the http://localhost:8000/hello/ URL, we get \nto see the Hello World message in the browser, which is in fact the output \nof hello.html ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 54}}, {"text": "FastAPI \u2013 Python Web Framework \n \n50 \n \n \nAs mentioned earlier, jinja2 template allows certain place holders to be \nembedded in the HTML code. The jinja2 code elements are put inside the \ncurly brackets. As soon as the HTML parser of the browser encounters this, \nthe template engine takes over and populates these code elements by the \nvariable data provided by the HTTP response. Jinja2 provides following code \nelements: \n\uf0b7 {% %} \u2013 Statements \n\uf0b7 {{ }} \u2013 Expressions to print to the template output", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 55}}, {"text": "llowing code \nelements: \n\uf0b7 {% %} \u2013 Statements \n\uf0b7 {{ }} \u2013 Expressions to print to the template output \n\uf0b7 {# #} \u2013 Comments which are not included in the template output \n\uf0b7 # # # \u2013 Line statements \nThe hello.html is modified as below to display a dynamic message by \nsubstituting the name parameter. \n<html> \n<body> \n<h2>Hello {{name}} Welcome to FastAPI</h2> \n</body> \n</html> \nThe operation function hello() is also modified to accept name as a path \nparameter. The TemplateResponse should also includ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 55}}, {"text": "ello() is also modified to accept name as a path \nparameter. The TemplateResponse should also include the JSON \nrepresentation of \u201cname\u201d:name along with the request context. \nfrom fastapi.responses import HTMLResponse \nfrom fastapi.templating import Jinja2Templates \nfrom fastapi import FastAPI, Request \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 55}}, {"text": "FastAPI \u2013 Python Web Framework \n \n51 \n \napp = FastAPI() \ntemplates = Jinja2Templates(directory=\"templates\") \n \n@app.get(\"/hello/{name}\", response_class=HTMLResponse) \nasync def hello(request: Request, name:str): \n    return templates.TemplateResponse(\"hello.html\", \n{\"request\": request, \"name\":name}) \nRestart the server and go to http://localhost:8000/hello/Kiran. The browser \nnow fills the jinja2 place holder with the path parameter in this URL. \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 56}}, {"text": "place holder with the path parameter in this URL. \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 56}}, {"text": "FastAPI \u2013 Python Web Framework \n \n52 \n \nOften it is required to include in the template response some resources that \nremain unchanged even if there is a certain dynamic data. Such resources \nare called static assets. Media files (.png, .jpg etc), JavaScript files to be \nused for executing some front end code, or stylesheets for formatting HTML \n(.CSS files) are the examples of static files. \nIn order to handle static files, you need a library called aiofiles \npip3 install aiofiles \nNext, import", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 57}}, {"text": "rder to handle static files, you need a library called aiofiles \npip3 install aiofiles \nNext, import StaticFiles class from the fastapi.staticfiles module. Its \nobject is one of the parameters for the mount() method of the FastAPI \napplication object to assign \"static\" subfolder in the current application \nfolder to store and serve all the static assets of the application. \napp.mount(app.mount(\"/static\", \nStaticFiles(directory=\"static\"), name=\"static\") \nExample \nIn the following example, FastAPI", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 57}}, {"text": "tatic\", \nStaticFiles(directory=\"static\"), name=\"static\") \nExample \nIn the following example, FastAPI logo is to be rendered in the hello.html \ntemplate. Hence, \u201cfa-logo.png\u201d file is first placed in static folder. It is now \navailable for using as src attribute of <img> tag in HTML code. \nfrom fastapi import FastAPI,  Request \nfrom fastapi.responses import HTMLResponse \nfrom fastapi.templating import Jinja2Templates \nfrom fastapi.staticfiles import StaticFiles \n \napp = FastAPI() \n \ntemplates = Ji", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 57}}, {"text": "rt Jinja2Templates \nfrom fastapi.staticfiles import StaticFiles \n \napp = FastAPI() \n \ntemplates = Jinja2Templates(directory=\"templates\") \n \napp.mount(\"/static\", StaticFiles(directory=\"static\"), \nname=\"static\") \n14. FastAPI \u2013 Static Files ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 57}}, {"text": "FastAPI \u2013 Python Web Framework \n \n53 \n \n     \n@app.get(\"/hello/{name}\", response_class=HTMLResponse) \nasync def hello(request: Request, name:str): \n    return templates.TemplateResponse(\"hello.html\", \n{\"request\": request, \"name\":name}) \nThe HTML code of \\templates\\hello.html is as follows: \n<html> \n<body> \n<h2>Hello {{name}} Welcome to FastAPI</h2> \n<img src=\"{{ url_for('static', path='fa-logo.png') }}\" alt=\"\" \nwidth=\"300\"> \n</body> \n</html> \nRun the Uvicorn server and visit the URL as http://lo", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 58}}, {"text": "') }}\" alt=\"\" \nwidth=\"300\"> \n</body> \n</html> \nRun the Uvicorn server and visit the URL as http://localhost/hello/Vijay. The \nLogo appears in the browser window as shown. \n \n \nExample \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 58}}, {"text": "FastAPI \u2013 Python Web Framework \n \n54 \n \nHere is another example of a static file. A JavaScript code hello.js contains \na definition of myfunction() to be executed on the onload event in \nfollowing HTML script (\\templates\\hello.html) \n<html> \n   <head> \n <title>My Website</title> \n <script src=\"{{ url_for('static', path='hello.js') }}\"></script> \n   </head> \n   <body onload=\"myFunction()\"> \n <div id=\"time\" style=\"text-align:right; width=\"100%\"></div> \n <h1><div id=\"ttl\">{{ name }}</div></h1> \n   ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 59}}, {"text": "d=\"time\" style=\"text-align:right; width=\"100%\"></div> \n <h1><div id=\"ttl\">{{ name }}</div></h1> \n   </body> \n</html> \nThe hello.js code is as follows: (\\static\\hello.js) \nfunction myFunction() { \n  var today = new Date(); \n  var h = today.getHours(); \n  var m = today.getMinutes(); \n  var s = today.getSeconds(); \n  var msg=\"\"; \n  if (h<12) \n  { \n   msg=\"Good Morning, \"; \n  } \n  if (h>=12 && h<18) \n  { \n   msg=\"Good Afternoon, \"; \n  } \n   if (h>=18) \n  { ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 59}}, {"text": "  { \n   msg=\"Good Afternoon, \"; \n  } \n   if (h>=18) \n  { ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 59}}, {"text": "FastAPI \u2013 Python Web Framework \n \n55 \n \n   msg=\"Good Evening, \"; \n  } \n  \nvar x=document.getElementById('ttl').innerHTML; \n  document.getElementById('ttl').innerHTML =  msg+x; \n  document.getElementById('time').innerHTML =  h + \":\" + m + \n\":\" + s; \n} \nThe function detects the value of current time and assigns appropriate value \nto msg variable (good morning, good afternoon or good evening) \ndepending on the time of the day. \nSave /static/hello.js, modify \\templates\\hello.html and restart the \nse", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 60}}, {"text": "ing on the time of the day. \nSave /static/hello.js, modify \\templates\\hello.html and restart the \nserver. The browser should show the current time and corresponding \nmessage below it. \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 60}}, {"text": "FastAPI \u2013 Python Web Framework \n \n56 \n \nLet us add another route \" /login\" to our application which renders a html \ntemplate having a simple login form. The HTML code for login page is as \nfollows: \n<html> \n   <body> \n      <form action=\"/submit\" method=\"POST\"> \n         <h3>Enter User name</h3> \n         <p><input type='text' name='nm'/></p> \n         <h3>Enter Password</h3> \n         <p><input type='password' name='pwd'/></p> \n         <p><input type='submit' value='Login'/></p> \n      </form>", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 61}}, {"text": "ype='password' name='pwd'/></p> \n         <p><input type='submit' value='Login'/></p> \n      </form> \n   </body> \n</html> \nNote that the action parameter is set to \"/submit\" route and action set to \nPOST. This will be significant for further discussion. \nAdd login() function in the main.py file as under: \n@app.get(\"/login/\", response_class=HTMLResponse) \nasync def login(request: Request): \n    return templates.TemplateResponse(\"login.html\", \n{\"request\": request}) \nThe URL http://localhost:8000/l", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 61}}, {"text": "urn templates.TemplateResponse(\"login.html\", \n{\"request\": request}) \nThe URL http://localhost:8000/login will render the login form as follows: \n15. FastAPI \u2013 HTML Form Templates ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 61}}, {"text": "FastAPI \u2013 Python Web Framework \n \n57 \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 62}}, {"text": "FastAPI \u2013 Python Web Framework \n \n58 \n \nNow we shall see how the HTML form data can be accessed in a FastAPI \noperation function. In the above example, the /login route renders a login \nform. The data entered by the user is submitted to /submit URL with POST \nas the request method. Now we have to provide a view function to process \nthe data submitted by the user. \nFastAPI has a Form class to process the data rece ived as a request by \nsubmitting an HTML form. However, you need to install the pyt", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 63}}, {"text": "ss the data rece ived as a request by \nsubmitting an HTML form. However, you need to install the python-\nmultipart module. It is a streaming multipart form parser for Python. \npip3 install python-multipart \nAdd Form class to the imported resources from FastAPI \nfrom fastapi import Form \nLet us define a submit() function to be decorated by @app.post(). In order \nto receive the form data, declare two parameters of Form type, having the \nsame name as the form attributes. \n@app.post(\"/submit/\") \nasy", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 63}}, {"text": "o parameters of Form type, having the \nsame name as the form attributes. \n@app.post(\"/submit/\") \nasync def submit(nm: str = Form(...), pwd: str = Form(...)): \n    return {\"username\": nm} \nPress submit after filling the text fields. The browser is redirected to /submit \nURL and the JSON response is rendered. Check the Swagger API docs of \nthe /submit route. It correctly identifies nm and pwd as the request body \nparameters and the form\u2019s  \"media type\" as application/x-www-form-\nurlencoded. \n16. F", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 63}}, {"text": " request body \nparameters and the form\u2019s  \"media type\" as application/x-www-form-\nurlencoded. \n16. FastAPI \u2013 Accessing Form Data ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 63}}, {"text": "FastAPI \u2013 Python Web Framework \n \n59 \n \n \nIt is even possible to populate and return Pydantic model with HTML form \ndata. In the following code, we declare User class as a Pydantic model and \nsend its object as the server\u2019 response. \nfrom pydantic import BaseModel \nclass User(BaseModel): \n    username:str \n    password:str \n \n@app.post(\"/submit/\", response_model=User) \nasync def submit(nm: str = Form(...), pwd: str = Form(...)): \n    return User(username=nm, password=pwd) \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 64}}, {"text": "orm(...), pwd: str = Form(...)): \n    return User(username=nm, password=pwd) \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 64}}, {"text": "FastAPI \u2013 Python Web Framework \n \n60 \n \nFirst of all, to send a file to the server you need to use the HTML form\u2019s \nenctype as multipart/form-data, and use the input type as the file to \nrender a button, which when clicked allows you to select a file from the file \nsystem. \n<html> \n   <body> \n      <form action=\"http://localhost:8000/uploader\" \nmethod=\"POST\" enctype=\"multipart/form-data\"> \n         <input type=\"file\" name=\"file\" /> \n         <input type=\"submit\"/> \n  </form> \n </body> \n</html>  ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 65}}, {"text": "  <input type=\"file\" name=\"file\" /> \n         <input type=\"submit\"/> \n  </form> \n </body> \n</html>  \nNote that the form\u2019s act ion parameter to the endpoint \nhttp://localhost:8000/uploader and the method is set to POST. \nThis HTML form is rendered as a template with following code: \nfrom fastapi import FastAPI, File, UploadFile, Request \nimport uvicorn \nimport shutil \n \nfrom fastapi.responses import HTMLResponse \nfrom fastapi.templating import Jinja2Templates \n \napp = FastAPI() \n \ntemplates = Jin", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 65}}, {"text": "t HTMLResponse \nfrom fastapi.templating import Jinja2Templates \n \napp = FastAPI() \n \ntemplates = Jinja2Templates(directory=\"templates\") \n17. FastAPI \u2013 Uploading Files ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 65}}, {"text": "FastAPI \u2013 Python Web Framework \n \n61 \n \n \n@app.get(\"/upload/\", response_class=HTMLResponse) \nasync def upload(request: Request): \n    return templates.TemplateResponse(\"uploadfile.html\", \n{\"request\": request}) \nVisit http://localhost:8000/upload/. You should get the form with Choose \nFile button. Click it to open the file to be uploaded. \n \nThe upload operation is handled by UploadFile function in FastAPI \nfrom fastapi import FastAPI, File, UploadFile \nimport shutil \n \n@app.post(\"/uploader/\") \na", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 66}}, {"text": " FastAPI \nfrom fastapi import FastAPI, File, UploadFile \nimport shutil \n \n@app.post(\"/uploader/\") \nasync def create_upload_file(file: UploadFile = File(...)): \n    with open(\"destination.png\", \"wb\") as buffer: \n        shutil.copyfileobj(file.file, buffer) \n     \n    return {\"filename\": file.filename} \nWe shall use shutil library in Python to copy the received file in the server \nlocation by the name destination.png \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 66}}, {"text": "ame destination.png \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 66}}, {"text": "FastAPI \u2013 Python Web Framework \n \n62 \n \nA cookie is one of the HTTP headers. The web server sends a response to \nthe client, in addition to the data requested, it also inserts one or more \ncookies. A cookie is a very small amount of data, that is stored  in the \nclient\u2019s machine. On subsequent connection requests from the same client, \nthis cookie data is also attached along with the HTTP requests.  \nThe cookies are useful for recording information about client\u2019s browsing. \nCookies are a reliabl", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 67}}, {"text": ".  \nThe cookies are useful for recording information about client\u2019s browsing. \nCookies are a reliable method of retrieving stateful information in otherwise \nstateless communication by HTTP protocol. \nIn FastAPI, the cookie parameter is set on the response object with the help \nof set_cookie() method \nresponse.set_cookie(key, value) \nExample \nHere is an example of set_cookie() method. We have a JSON response \nobject called content. Call the set_cookie() method on it to set a cookie \nas key=\"usrn", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 67}}, {"text": "ON response \nobject called content. Call the set_cookie() method on it to set a cookie \nas key=\"usrname\" and value=\"admin\": \nfrom fastapi import FastAPI \nfrom fastapi.responses import JSONResponse \n \napp = FastAPI() \n@app.post(\"/cookie/\") \ndef create_cookie(): \n    content = {\"message\": \"cookie set\"} \n    response = JSONResponse(content=content) \n    response.set_cookie(key=\"username\", value=\"admin\") \n    return response \nTo read back the cookie on a subsequent visit, use the Cookie object in th", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 67}}, {"text": "n\") \n    return response \nTo read back the cookie on a subsequent visit, use the Cookie object in the \nFastAPI library. \n18. FastAPI \u2013 Cookie Parameters ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 67}}, {"text": "FastAPI \u2013 Python Web Framework \n \n63 \n \nfrom fastapi import FastAPI, Cookie \napp = FastAPI() \n@app.get(\"/readcookie/\") \nasync def read_cookie(username: str = Cookie(None)): \n    return {\"username\": username} \nInspect these two endpoints in the Swagger API. There are these two routes \n\"/cookies\" and \"/readcookie\". Execute the create_cookie() function \nbound to \"/cookies\". The response is just the content, although the cookie \nis set. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 68}}, {"text": "ontent, although the cookie \nis set. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 68}}, {"text": "FastAPI \u2013 Python Web Framework \n \n64 \n \nWhen the read_cookie() function is executed, the cookie is read back and \nappears as the response. Also, not that the documentation identifies the \nuser name as a cookie parameter. \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 69}}, {"text": "FastAPI \u2013 Python Web Framework \n \n65 \n \nIn order to read the values of an HTTP header that is a part of the client \nrequest, import the Header object from the FastAPI library, and declare a \nparameter of Header type in the operation function definition. The name of \nthe parameter should match with the HTTP header converted in \ncamel_case.  \nIn the following example, the \"accept-language\" header is to be retrieved. \nSince Python doesn\u2019t allow \"-\" (dash) in the name of identifier, it is replaced \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 70}}, {"text": " to be retrieved. \nSince Python doesn\u2019t allow \"-\" (dash) in the name of identifier, it is replaced \nby \"_\" (underscore) \nfrom typing import Optional \nfrom fastapi import FastAPI, Header \n \napp = FastAPI() \n@app.get(\"/headers/\") \nasync def read_header(accept_language: Optional[str] = \nHeader(None)): \n    return {\"Accept-Language\": accept_language}  \nAs the following Swagger documentation shows, the retrieved header is \nshown as the response body. \n19. FastAPI \u2013 Header Parameters ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 70}}, {"text": " retrieved header is \nshown as the response body. \n19. FastAPI \u2013 Header Parameters ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 70}}, {"text": "FastAPI \u2013 Python Web Framework \n \n66 \n \n \nYou can push custom as well as predefined headers in the response object. \nThe operation function should have a parameter of Response type. In order \nto set a custom header, its name should be prefixed with \"X\". In the \nfollowing case, a custom header called \"X -Web-Framework\" and a \npredefined header \u201cContent-Language\" is added along with the response of \nthe operation function. \nfrom fastapi import FastAPI \nfrom fastapi.responses import JSONResponse \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 71}}, {"text": "\nthe operation function. \nfrom fastapi import FastAPI \nfrom fastapi.responses import JSONResponse \n \napp = FastAPI() \n \n@app.get(\"/rspheader/\") \ndef set_rsp_headers(): \n    content = {\"message\": \"Hello World\"} \n    headers = {\"X-Web-Framework\": \"FastAPI\", \"Content-Language\": \"en-US\"} \n    return JSONResponse(content=content, headers=headers)  \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 71}}, {"text": "FastAPI \u2013 Python Web Framework \n \n67 \n \nThe newly added headers will appear in the response header section of the \ndocumentation. \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 72}}, {"text": "FastAPI \u2013 Python Web Framework \n \n68 \n \nAn operation function returns A JSON response to the client. The response \ncan be in the form of Python primary types , i.e., numbers, string, list or \ndict, etc. It can also be in the form of a Pydantic model. For a function to \nreturn a model object, the operation decorator should declare a \nrespone_model parameter. \nWith the help of response_model, FastAPI Converts the output data to a \nstructure of a model class. It validates the data, adds a JSON Sche", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 73}}, {"text": "I Converts the output data to a \nstructure of a model class. It validates the data, adds a JSON Schema for \nthe response, in the OpenAPI path operation.  \nOne of the important advantages of response_model parameter is that we \ncan format the output by selecting the fields from the model to cast the \nresponse to an output model. \nExample \nIn the following example, the POST operation decorator r eceives the \nrequest body in the form of an object of the student class (a subclass of \nBaseModel). As ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 73}}, {"text": "ives the \nrequest body in the form of an object of the student class (a subclass of \nBaseModel). As one of the fields in this class, i.e. marks (a list of marks) is \nnot needed in the response, we define another model called percent and \nuse it as the response_model parameter. \nfrom typing import List \nfrom fastapi import FastAPI \nfrom pydantic import BaseModel, Field \n \napp = FastAPI() \n \nclass student(BaseModel): \n    id: int \n    name :str = Field(None, title=\"name of student\", max_length=10)", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 73}}, {"text": "tudent(BaseModel): \n    id: int \n    name :str = Field(None, title=\"name of student\", max_length=10) \n    marks: List[int] = [] \n    percent_marks: float \nclass percent(BaseModel): \n20. FastAPI \u2013 Response Model ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 73}}, {"text": "FastAPI \u2013 Python Web Framework \n \n69 \n \n    id:int \n    name :str = Field(None, title=\"name of student\", max_length=10) \n    percent_marks: float \n \n@app.post(\"/marks\", response_model=percent) \nasync def get_percent(s1:student): \n    s1.percent_marks=sum(s1.marks)/2 \n    return s1 \nIf we check the Swagger documentation, it shows that the \"/marks\" route \ngets an object of student class as the request body. Populate the attributes \nwith appropriate values and execute the get_percent() function. \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 74}}, {"text": "st body. Populate the attributes \nwith appropriate values and execute the get_percent() function. \n \nThe server response is cast to the percent class as it has been used as the \nresponse_model. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 74}}, {"text": "FastAPI \u2013 Python Web Framework \n \n70 \n \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 75}}, {"text": "FastAPI \u2013 Python Web Framework \n \n71 \n \nEach attribute of a Pydantic model has a type. The type can be a built -in \nPython type or a model itself. Hence it is possible to declare nested JSON \n\"objects\" with specific attribute names, types, and validations.  \nExample \nIn the following example, we construct a customer model with one of the \nattributes as product model class. The product model in turn has an \nattribute of supplier class. \nfrom typing import Tuple \nfrom fastapi import FastAPI \nfrom ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 76}}, {"text": "n has an \nattribute of supplier class. \nfrom typing import Tuple \nfrom fastapi import FastAPI \nfrom pydantic import BaseModel \napp = FastAPI() \n \nclass supplier(BaseModel): \n    supplierID:int \n    supplierName:str \n \nclass product(BaseModel): \n    productID:int \n    prodname:str \n    price:int \n    supp:supplier \n \nclass customer(BaseModel): \n    custID:int \n    custname:str \n    prod:Tuple[product] \n21. FastAPI \u2013 Nested Models ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 76}}, {"text": "ct] \n21. FastAPI \u2013 Nested Models ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 76}}, {"text": "FastAPI \u2013 Python Web Framework \n \n72 \n \nThe following POST operation decorator renders the object of the customer \nmodel as the server response. \n@app.post('/invoice') \nasync def getInvoice(c1:customer): \n    return c1 \nThe swagger UI page reveals the presence of three schemas, corresponding \nto three BaseModel classes.  \n \nThe Customer schema when expanded to show all the nodes looks like this: \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 77}}, {"text": "FastAPI \u2013 Python Web Framework \n \n73 \n \n \nAn example response of \"/invoice\" route should be as follows: \n{ \n  \"custID\": 1, \n  \"custname\": \"Jay\", \n  \"prod\": [ \n    { \n      \"productID\": 1, \n      \"prodname\": \"LAPTOP\", \n      \"price\": 40000, \n      \"supp\": { \n        \"supplierID\": 1, \n        \"supplierName\": \"Dell\" \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 78}}, {"text": "FastAPI \u2013 Python Web Framework \n \n74 \n \n      } \n    } \n  ] \n} \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 79}}, {"text": "FastAPI \u2013 Python Web Framework \n \n75 \n \nThe built-in dependency injection system of FastAPI makes it possible to \nintegrate components easier when building your API. In programming, \nDependency injection refers to the mechanism where an object receives \nother objects that it depends on. The other objects are called dependencies. \nDependency injection has the following advantages: \n\uf0b7 reuse the same shared logic \n \n\uf0b7 share database connections \n \n\uf0b7 enforce authentication and security features \n \nA", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 80}}, {"text": " shared logic \n \n\uf0b7 share database connections \n \n\uf0b7 enforce authentication and security features \n \nAssuming that a FastAPI app has two operation functions both having th e \nsame query parameters id, name and age. \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.get(\"/user/\") \nasync def user(id: str, name: str, age: int): \n    return {\"id\": id, \"name\": name, \"age\": age} \n \n@app.get(\"/admin/\") \nasync def admin(id: str, name: str, age: int): \n    return {\"id\": id, \"name\": name, \"age\": age} \nIn", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 80}}, {"text": "\nasync def admin(id: str, name: str, age: int): \n    return {\"id\": id, \"name\": name, \"age\": age} \nIn case of any changes such as adding/removing query parameters, both \nthe route decorators and functions need to be changed.  \nFastAPI provides Depends class and its object is used as a common \nparameter in such cases. First import Depends from FastAPI and define a \nfunction to receive these parameters: \nasync def dependency(id: str, name: str, age: int): \n    return {\"id\": id, \"name\": name, \"age\":", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 80}}, {"text": "rs: \nasync def dependency(id: str, name: str, age: int): \n    return {\"id\": id, \"name\": name, \"age\": age} \n22. FastAPI \u2013 Dependencies ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 80}}, {"text": "FastAPI \u2013 Python Web Framework \n \n76 \n \nNow we can use the return value of this function as a parameter in operation \nfunctions \n@app.get(\"/user/\") \nasync def user(dep: dict = Depends(dependency)): \n    return dep \nFor each new Request, FastAPI calls the dependency function using the \ncorresponding parameters, returns the result, and assigns the result to your \noperation. \nYou can use a class for managing dependencies instead of a function. \nDeclare a class with id, name and age as attributes. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 81}}, {"text": "managing dependencies instead of a function. \nDeclare a class with id, name and age as attributes. \nclass dependency: \n    def __init__(self, id: str, name: str, age: int): \n        self.id = id \n        self.name = name \n        self.age = age  \nUse this class as the type of parameters. \n@app.get(\"/user/\") \nasync def user(dep: dependency = Depends(dependency)): \n    return dep \n \n@app.get(\"/admin/\") \nasync def admin(dep: dependency = Depends(dependency)): \n    return dep \nHere, we used the depe", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 81}}, {"text": "/\") \nasync def admin(dep: dependency = Depends(dependency)): \n    return dep \nHere, we used the dependency injection in the operation function. It can \nalso be used as operation decoration. For example, we want to check if the \nvalue of query parameter age is less than 21. If yes it should throw an \nexception. So, we write a function to check it and use it as a dependency. \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 81}}, {"text": "FastAPI \u2013 Python Web Framework \n \n77 \n \nasync def validate(dep: dependency = Depends(dependency)): \n    if dep.age < 18: \n        raise HTTPException(status_code=400, detail=\"You are \nnot eligible\") \n@app.get(\"/user/\", dependencies=[Depends(validate)]) \nasync def user(): \n    return {\"message\": \"You are eligible\"} \nIn FastAPI dependency management, you can use yield instead of return to \nadd some extra steps. For example, the following function uses database \ndependency with yield. \nasync def ge", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 82}}, {"text": "extra steps. For example, the following function uses database \ndependency with yield. \nasync def get_db(): \n    db = DBSession() \n    try: \n        yield db \n    finally: \n        db.close() ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 82}}, {"text": "FastAPI \u2013 Python Web Framework \n \n78 \n \nCross-Origin Resource Sharing  (CORS) is a situation when a frontend  \napplication that is running on one client browser tries to communicate with \na backend through JavaScript code, and the backend is in a different \"origin\" \nthan the frontend.  The origin here is a combination of protocol, domain \nname, and port numbers. As a result, http://localhost and https://localhost \nhave different origins. \nIf the browser with a URL of one origin sends a request f", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 83}}, {"text": "ttps://localhost \nhave different origins. \nIf the browser with a URL of one origin sends a request for the execution of \nJavaScript code from another origin, the browser sends an OPTIONS HTTP \nrequest. \nIf the backend authorizes the communication from this different origin by  \nsending the appropriate headers it will let the JavaScript in the frontend \nsend its request to the backend. For that, the backend must have a list of \n\"allowed origins\". \nTo specify explicitly the allowed origins, import", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 83}}, {"text": "e backend must have a list of \n\"allowed origins\". \nTo specify explicitly the allowed origins, import CORSMiddleware and add \nthe list of origins to the app's middleware. \nfrom fastapi import FastAPI \nfrom fastapi.middleware.cors import CORSMiddleware \n \napp = FastAPI() \n \norigins = [ \n    \"http://192.168.211.:8000\", \n    \"http://localhost\", \n    \"http://localhost:8080\", \n] \n \napp.add_middleware( \n    CORSMiddleware, \n    allow_origins=origins, \n23. FastAPI \u2013 CORS ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 83}}, {"text": "    CORSMiddleware, \n    allow_origins=origins, \n23. FastAPI \u2013 CORS ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 83}}, {"text": "FastAPI \u2013 Python Web Framework \n \n79 \n \n    allow_credentials=True, \n    allow_methods=[\"*\"], \n    allow_headers=[\"*\"], \n) \n \n@app.get(\"/\") \nasync def main(): \n    return {\"message\": \"Hello World\"} \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 84}}, {"text": "FastAPI \u2013 Python Web Framework \n \n80 \n \nThe REST architecture uses HTTP verbs or methods for the operation on the \nresources. The POST, GET, PUT and DELETE methods perform respectively \nCREATE, READ, UPDATE and DELETE operations respectively. \nIn the following example, we shall use a Python list as an in -memory \ndatabase and perf orm the CRUD operations on it. First, let us set up a \nFastAPI app object and declare a Pydantic model called Book. \nfrom fastapi import FastAPI \nfrom pydantic import ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 85}}, {"text": "object and declare a Pydantic model called Book. \nfrom fastapi import FastAPI \nfrom pydantic import BaseModel \n \napp = FastAPI() \n \ndata = [] \n \nclass Book(BaseModel): \n    id: int \n    title: str \n    author: str \n    publisher: str \nAn object of this model is populated using the @app.post() decorator and \nit is appended to the list of books (data is declared for the list of books) \n@app.post(\"/book\") \ndef add_book(book: Book): \n    data.append(book.dict()) \n    return data \nIn the Swagger UI, ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 85}}, {"text": "ook\") \ndef add_book(book: Book): \n    data.append(book.dict()) \n    return data \nIn the Swagger UI, execute this operation function a couple of times and \nadd some data. \n24. FastAPI \u2013 CRUD Operations ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 85}}, {"text": "FastAPI \u2013 Python Web Framework \n \n81 \n \n \nThe server\u2019s JSON response shows the list of books added so far. \n \nTo retrieve the list, define an operation function bound to the @app.get() \ndecorator as follows: \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 86}}, {"text": "FastAPI \u2013 Python Web Framework \n \n82 \n \n@app.get(\"/list\") \ndef get_books(): \n    return data \nTo retrieve a book with its id as a path parameter, define the get() operation \ndecorator and get_book() function as below: \n@app.get(\"/book/{id}\") \ndef get_book(id: int): \n    id = id - 1 \n    return data[id] \nThe /list route retrieves all the books. ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 87}}, {"text": "FastAPI \u2013 Python Web Framework \n \n83 \n \n \nOn the other hand, use \"id\" as the path parameter in the \"/book/1\" route.  \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 88}}, {"text": "FastAPI \u2013 Python Web Framework \n \n84 \n \n \nThe book with \"id=1\" will be retrieved as can be seen in the server response \nof Swagger UI \n \nNext, define @app.put() decorator that modifies an object in the data list. \nThis decorator too has a path parameter for the id field. \n@app.put(\"/book/{id}\") \ndef add_book(id: int, book: Book): \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 89}}, {"text": "FastAPI \u2013 Python Web Framework \n \n85 \n \n    data[id-1] = book \n    return data \nInspect this operation function in the swagger UI . Give id=1, and change \nvalue of publisher to BPB in the request body. \n \nWhen executed, the response shows the list with object with id=1 updated \nwith the new values. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 90}}, {"text": "FastAPI \u2013 Python Web Framework \n \n86 \n \n \nFinally, we define the @app.delete() decorator to delete an object \ncorresponding to the path parameter. \n@app.delete(\"/book/{id}\") \ndef delete_book(id: int): \n    data.pop(id-1) \n    return data \nGive id=1 as the path parameter and execute the function. \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 91}}, {"text": "FastAPI \u2013 Python Web Framework \n \n87 \n \n \nUpon execution, the list now shows only two objects. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 92}}, {"text": "FastAPI \u2013 Python Web Framework \n \n88 \n \nIn the previo us chapter, a Python list has been used as an in -memory \ndatabase to perform CRUD operations using FastAPI. Instead, we can use \nany relational database (such as MySQL, Oracle, etc.) to perform store, \nretrieve, update and delete operations. \nInstead of using a DB-API compliant database driver, we shall use \nSQLAlchemy as an interface between Python code and a database (we are \ngoing to use SQLite database as Python has in -built support for", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 93}}, {"text": "Python code and a database (we are \ngoing to use SQLite database as Python has in -built support for it). \nSQLAlchemy is a popular SQL toolkit and Object Relational Mapper. \nObject Relational Mapping is a programming technique for converting data \nbetween incompatible type systems in object -oriented programming \nlanguages. Usually, the type system used in an Object -Oriented language \nlike Python contains non -scalar types. However, data types in most of the \ndatabase products such as Oracle, M", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 93}}, {"text": " contains non -scalar types. However, data types in most of the \ndatabase products such as Oracle, MySQL, etc., are of primitive types such \nas integers and strings. \nIn an ORM system, each class maps to a table in the underlying database. \nInstead of writing tedious database interfacing code yourself, an ORM takes \ncare of these issues for you while you can focus on programming the logics \nof the system. \nIn order to use SQLAlchemy, we need to first install the library using the \nPIP installer.", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 93}}, {"text": " system. \nIn order to use SQLAlchemy, we need to first install the library using the \nPIP installer. \npip install sqlalchemy \nSQLAlchemy is designed to operat e with a DBAPI implementation built for \na particular database. It uses dialect system to communicate with various \ntypes of DBAPI implementations and databases. All dialects require that an \nappropriate DBAPI driver is installed.  \nThe following are the dialects included \u2212 \n\uf0b7 Firebird \n\uf0b7 Microsoft SQL Server \n\uf0b7 MySQL \n\uf0b7 Oracle \n\uf0b7 PostgreS", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 93}}, {"text": "owing are the dialects included \u2212 \n\uf0b7 Firebird \n\uf0b7 Microsoft SQL Server \n\uf0b7 MySQL \n\uf0b7 Oracle \n\uf0b7 PostgreSQL \n25. FastAPI \u2013 SQL Databases ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 93}}, {"text": "FastAPI \u2013 Python Web Framework \n \n89 \n \n\uf0b7 SQLite \n\uf0b7 Sybase \nSince we are going to use SQLite database, we need to create a database \nengine for our database called test.db. Import create_engine() function \nfrom sqlalchemy module. \nfrom sqlalchemy import create_engine \nfrom sqlalchemy.dialects.sqlite import * \nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\" \nengine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args = \n{\"check_same_thread\": False}) \nIn order to interact with the database, we  n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 94}}, {"text": "SE_URL, connect_args = \n{\"check_same_thread\": False}) \nIn order to interact with the database, we  need to obtain its handle. A \nsession object is the handle to database. Session class is defined using \nsessionmaker() \u2013 a configurable session factory method which is bound \nto the engine object. \nfrom sqlalchemy.orm import sessionmaker, Session \nsession = sessionmaker(autocommit=False, autoflush=False, \nbind=engine) \nNext, we need a declarative base class that stores a catalog of classes and \nmap", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 94}}, {"text": "lse, \nbind=engine) \nNext, we need a declarative base class that stores a catalog of classes and \nmapped tables in the Declarative system.  \nfrom sqlalchemy.ext.declarative import declarative_base \nBase = declarative_base() \nBooks, a subclass of Base, is mapped to a book table in the database. \nAttributes in the Books class correspond to the data types of the columns \nin the target table. Note that the id attribute corresponds to the primary \nkey in the book table. \nfrom sqlalchemy import Column,", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 94}}, {"text": " the id attribute corresponds to the primary \nkey in the book table. \nfrom sqlalchemy import Column, Integer, String \nclass Books(Base): \n    __tablename__ = 'book' \n    id = Column(Integer, primary_key=True, nullable=False) \n    title = Column(String(50), unique=True) ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 94}}, {"text": "FastAPI \u2013 Python Web Framework \n \n90 \n \n    author = Column(String(50)) \n    publisher = Column(String(50)) \nBase.metadata.create_all(bind=engine) \nThe create_all() method creates the corresponding tables in the database. \nWe now have to declare a Pydantic model that corresponds to the \ndeclarative base subclass (Books class defined above). \nfrom typing import List \nfrom pydantic import BaseModel, constr \n \nclass Book(BaseModel): \n    id: int \n    title: str \n    author:str \n    publisher: str \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 95}}, {"text": " constr \n \nclass Book(BaseModel): \n    id: int \n    title: str \n    author:str \n    publisher: str \n \n    class Config: \n        orm_mode = True \nNote the use of orm_mode=True in the config class indicating that it is \nmapped with the ORM class of SQLAlchemy. \nRest of the code is just similar to in -memory CRUD operations, with the \ndifference being the operation functions interact with the database through \nSQLalchemy interface. The POST operation on the FastAPI application \nobject is defined b", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 95}}, {"text": "se through \nSQLalchemy interface. The POST operation on the FastAPI application \nobject is defined below: \nfrom fastapi import FastAPI, Depends \napp=FastAPI() \n \ndef get_db(): \n    db = session() \n    try: \n        yield db \n    finally: ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 95}}, {"text": "FastAPI \u2013 Python Web Framework \n \n91 \n \n        db.close() \n \n@app.post('/add_new', response_model=Book) \ndef add_book(b1: Book, db: Session = Depends(get_db)): \n    bk=Books(id=b1.id, title=b1.title, author=b1.author, \npublisher=b1.publisher) \n    db.add(bk) \n    db.commit() \n    db.refresh(bk) \n    return Books(**b1.dict()) \nA database session is first established. Data from the POST request body is \nadded to the book table as a new row. Execute the add_book() operation \nfunction to add sample", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 96}}, {"text": "y is \nadded to the book table as a new row. Execute the add_book() operation \nfunction to add sample data to the books table. To verify, you can use \nSQLiteStudio, a GUI tool for SQLite databases. \n \nTwo operation functions for GET operation are defined, one for fetching all \nthe records, and one for the record matching a path parameter. \nFollowing is the get_books() function bound to the /list route. When \nexecuted, its server response is the list of all records. \n@app.get('/list', response_mod", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 96}}, {"text": "ute. When \nexecuted, its server response is the list of all records. \n@app.get('/list', response_model=List[Book]) \ndef get_books(db: Session = Depends(get_db)): \n    recs = db.query(Books).all() \n    return recs \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 96}}, {"text": "FastAPI \u2013 Python Web Framework \n \n92 \n \nThe /book/{id} route calls the get_book() function with id as path \nparameter. The SQLAlchemy\u2019s query returns an object corresponding to the \ngiven id. \n@app.get('/book/{id}', response_model=Book) \ndef get_book(id:int, db: Session = Depends(get_db)): \n    return db.query(Books).filter(Books.id == id).first() \nThe following image shows the result of get_books() function executed \nfrom the Swagger UI. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 97}}, {"text": "() function executed \nfrom the Swagger UI. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 97}}, {"text": "FastAPI \u2013 Python Web Framework \n \n93 \n \nThe update and delete operations are performed by update_book() \nfunction (executed when /update/{id} route is visited) and del_book() \nfunction called when the route /delete/{id} is given in as the URL. \n@app.put('/update/{id}', response_model=Book) \ndef update_book(id:int, book:Book, db: Session = Depends(get_db)): \n    b1 = db.query(Books).filter(Books.id == id).first() \n    b1.id=book.id \n    b1.title=book.title \n    b1.author=book.author \n    b1.publi", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 98}}, {"text": " == id).first() \n    b1.id=book.id \n    b1.title=book.title \n    b1.author=book.author \n    b1.publisher=book.publisher \n    db.commit() \n    return db.query(Books).filter(Books.id == id).first() \n \n@app.delete('/delete/{id}') \ndef del_book(id:int, db: Session = Depends(get_db)): \n    try: \n        db.query(Books).filter(Books.id == id).delete() \n        db.commit() \n    except Exception as e: \n        raise Exception(e) \n    return {\"delete status\": \"success\"} \nIf you intend to use any other da", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 98}}, {"text": "      raise Exception(e) \n    return {\"delete status\": \"success\"} \nIf you intend to use any other database in place of SQLite, you need to only \nthe change the dialect definition accordingly. For example, to use MySQL \ndatabase and pymysql driver, change the statement of engine object t o \nthe following: \nengine = \ncreate_engine('mysql+pymysql://user:password@localhost/test') \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 98}}, {"text": "FastAPI \u2013 Python Web Framework \n \n94 \n \nFastAPI can also use NoSQL databases such as MongoDB, Cassandra, \nCouchDB, etc. as the backend for the CRUD operations of a REST app. In \nthis topic, we shall see how to use MongoDB in a FastAPI application. \nMongoDB is a d ocument oriented database, in which t he semi-structured \ndocuments are stored in formats like JSON. Documents can contain many \ndifferent key-value pairs, or key-array pairs, or even nested documents. It \nis a collection of key-value p", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 99}}, {"text": "nt key-value pairs, or key-array pairs, or even nested documents. It \nis a collection of key-value pairs, similar to Python dictionary object. One or \nmore such documents are stored in a Collection.  \nA Collection in MongoDB is equivalent to a table in relational database. \nHowever, MongoDB (as do all the NoSQL databases) doesn't have a \npredefined schema. A Document is similar to single row in a table of SQL \nbased relational database. Each document may be of variable number of \nkey-value pairs", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 99}}, {"text": "table of SQL \nbased relational database. Each document may be of variable number of \nkey-value pairs. Thus MongoDB is a schema-less database. \nTo use MongoDB with FastAPI, MongoDB server must be installed on the \nmachine. We also need to install PyMongo, an official Python driver for \nMongoDB. \npip3 install pymongo \nBefore interacting with MongoDB database through Python and FastAPI \ncode, ensure that MongoDB is running by issuing following command \n(assuming that MongoDB server is installed in ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 99}}, {"text": "that MongoDB is running by issuing following command \n(assuming that MongoDB server is installed in e:\\mongodb folder). \nE:\\mongodb\\bin>mongod \n.. \nwaiting for connections on port 27017  \nAn object of MongoClient class in the PyMongo module is the handle using \nwhich Python interacts with MongoDB server. \nfrom pymongo import MongoClient \nclient=MongoClient() \n26. FastAPI \u2013 Using MongoDB ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 99}}, {"text": "FastAPI \u2013 Python Web Framework \n \n95 \n \nWe define Book as the BaseModel class to populate the request body (same \nas the one used in the SQLite example) \nfrom pydantic import BaseModel \nfrom typing import List \nclass Book(BaseModel): \n    bookID: int \n    title: str \n    author:str \n    publisher: str \nSet up the FastAPI application object: \nfrom fastapi import FastAPI, status \napp = FastAPI() \nThe POST operation decorator has \"/add_new\" as URL route and executes \nadd_book() function. It parses ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 100}}, {"text": "e POST operation decorator has \"/add_new\" as URL route and executes \nadd_book() function. It parses the Book BaseModel object into a dictionary \nand adds a document in the BOOK_COLLECTION of test database. \n@app.post(\"/add_new\", status_code=status.HTTP_201_CREATED) \ndef add_book(b1: Book): \n    \"\"\"Post a new message to the specified channel.\"\"\" \n    with MongoClient() as client: \n        book_collection = client[DB][BOOK_COLLECTION] \n        result = book_collection.insert_one(b1.dict()) \n      ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 100}}, {"text": "ection = client[DB][BOOK_COLLECTION] \n        result = book_collection.insert_one(b1.dict()) \n        ack = result.acknowledged \n        return {\"insertion\": ack} \nAdd a few documents using the web interface of Swagger UI by visiting \nhttp://localhost:8000/docs. You can verify the collection in the Compass \nGUI front end for MongoDB. ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 100}}, {"text": "FastAPI \u2013 Python Web Framework \n \n96 \n \n \nTo retrieve the list of all books, let us include the following get operation \nfunction \u2013 get_books(). It will be executed when \" /books\" URL route is \nvisited. \n@app.get(\"/books\", response_model=List[str]) \ndef get_books(): \n    \"\"\"Get all books in list form.\"\"\" \n    with MongoClient() as client: \n        book_collection = client[DB][BOOK_COLLECTION] \n        booklist = book_collection.distinct(\"title\") \n        return booklist \nIn this case, the server", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 101}}, {"text": "     booklist = book_collection.distinct(\"title\") \n        return booklist \nIn this case, the server response will be the list of all titles in the books \ncollection. \n[ \n  \"Computer Fundamentals\", \n  \"Python Cookbook\", \n  \"Let Us Python\" \n] \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 101}}, {"text": "FastAPI \u2013 Python Web Framework \n \n97 \n \nThis following GET decorator retrieves a book document corresponding to \ngiven ID as path parameter: \n@app.get(\"/books/{id}\", response_model=Book) \ndef get_book(id: int): \n    \"\"\"Get all messages for the specified channel.\"\"\" \n    with MongoClient() as client: \n        book_collection = client[DB][BOOK_COLLECTION] \n        b1 = book_collection.find_one({\"bookID\": id}) \n        return b1 \nSwagger UI documentation page shows the following interface: \n \n \n \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 102}}, {"text": "kID\": id}) \n        return b1 \nSwagger UI documentation page shows the following interface: \n \n \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 102}}, {"text": "FastAPI \u2013 Python Web Framework \n \n98 \n \nThe server\u2019s JSON response, when the above function is executed, is as \nfollows: \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 103}}, {"text": "FastAPI \u2013 Python Web Framework \n \n99 \n \nFacebook developed GraphQL in 2012, a new API standard with the \nintention of optimizing RESTful API Calls. GraphQL is the data query and \nmanipulation language for the API. GraphQL is more flexible, efficient, and \naccurate as compared to REST. A  GraphQL server provides only a single \nendpoint and responds with the precise data required by the client. \nAs GraphQL is compatible with ASGI, it can be easily i ntegrated with a \nFastAPI application. There are", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 104}}, {"text": "GraphQL is compatible with ASGI, it can be easily i ntegrated with a \nFastAPI application. There are many Python libraries for GraphQL. Some of \nthem are listed below: \n\uf0b7 Strawberry  \n\uf0b7 Ariadne \n\uf0b7 Tartiflette \n\uf0b7 Graphene \nFastAPI\u2019s official documentation recommends using Strawberry library as \nits design is also based on type annotations (as in the case of FastAPI itself). \nIn order to integrate GraphQL with a FastAPI app, first decorate a Python \nclass as Strawberry type. \n@strawberry.type \ncla", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 104}}, {"text": "raphQL with a FastAPI app, first decorate a Python \nclass as Strawberry type. \n@strawberry.type \nclass Book: \n    title: str \n    author: str \n    price: int  \nNext, declare a Query class containing a function that returns a Book \nobject. \n@strawberry.type \nclass Query: \n    @strawberry.field \n    def book(self) -> Book: \n        return Book(title=\"Computer Fundamentals\", \nauthor=\"Sinha\", price=300) \n27. FastAPI \u2013 Using GraphQL ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 104}}, {"text": "0) \n27. FastAPI \u2013 Using GraphQL ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 104}}, {"text": "FastAPI \u2013 Python Web Framework \n \n100 \n \nUse this Query class as the parameter to obtain Strawberry.Schema object. \nschema = strawberry.Schema(query=Query) \nThen declare the objects of both GraphQL class and FastAPI application class. \ngraphql_app = GraphQL(schema) \napp = FastAPI() \nFinally, add routes to the FastAPI object and run the server. \napp.add_route(\"/book\", graphql_app) \napp.add_websocket_route(\"/book\", graphql_app) \nVisit http://localhost:8000/book in the browser. An in -browser Graph", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 105}}, {"text": "t_route(\"/book\", graphql_app) \nVisit http://localhost:8000/book in the browser. An in -browser GraphQL \nIDE opens up. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 105}}, {"text": "FastAPI \u2013 Python Web Framework \n \n101 \n \nBelow the commented section, enter the following query using the Explorer \nbar of the Graphiql IDE. Run the query to display the result in the output \npane. \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 106}}, {"text": "FastAPI \u2013 Python Web Framework \n \n102 \n \nA WebSocket is a persistent connection between a client and server  to \nprovide bidirectional, full-duplex communication between the two. The \ncommunication takes place over HTTP through a single TCP/IP socket \nconnection. It can be seen as an upgrade of HTTP instead of a protocol \nitself.  \nOne of the limitations of HTTP is that it is a strictly half -duplex or \nunidirectional protocol. With WebSockets, on the other hand, we can send \nmessage-based data,", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 107}}, {"text": "ex or \nunidirectional protocol. With WebSockets, on the other hand, we can send \nmessage-based data, similar to UDP, but with the reliability of TCP. \nWebSocket uses HTTP as the initial transport mechanism, but keeps the \nTCP connection alive the connection after the HTTP resp onse is received . \nSame connection object it can be used two-way communication  between \nclient and server. Thus, real-time applications can be built using WebSocket \nAPIs. \nFastAPI supports WebSockets through WebSocket c", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 107}}, {"text": "me applications can be built using WebSocket \nAPIs. \nFastAPI supports WebSockets through WebSocket class in FastAPI module. \nFollowing exampl e demonstrates functioning of WebSocket in FastAPI \napplication. \nFirst we have an index() function that renders a template (socket.html). It \nis bound to \"/\" route. The HTML file socket.html is placed in the \u201ctemplates\u201d \nfolder. \nmain.py \nfrom fastapi import FastAPI,  Request \nfrom fastapi.responses import HTMLResponse \nfrom fastapi.templating import Jinj", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 107}}, {"text": "t FastAPI,  Request \nfrom fastapi.responses import HTMLResponse \nfrom fastapi.templating import Jinja2Templates \ntemplates = Jinja2Templates(directory=\"templates\") \n \nfrom fastapi.staticfiles import StaticFiles \n \napp = FastAPI() \n \napp.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\") \n \n28. FastAPI \u2013 WebSockets ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 107}}, {"text": "FastAPI \u2013 Python Web Framework \n \n103 \n \n@app.get(\"/\", response_class=HTMLResponse) \nasync def index(request: Request): \n    return templates.TemplateResponse(\"socket.html\", {\"request\": \nrequest}) \nThe template file renders a text box and a button. \nsocket.html \n<!DOCTYPE html> \n<html> \n    <head> \n        <title>Chat</title> \n  <script src=\"{{ url_for('static', \npath='ws.js') }}\"></script> \n    </head> \n    <body>  \n        <h1>WebSocket Chat</h1> \n        <form action=\"\" onsubmit=\"sendMessage(", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 108}}, {"text": "/head> \n    <body>  \n        <h1>WebSocket Chat</h1> \n        <form action=\"\" onsubmit=\"sendMessage(event)\"> \n            <input type=\"text\" id=\"messageText\" \nautocomplete=\"off\"/> \n            <button>Send</button> \n        </form> \n        <ul id='messages'> \n        </ul> \n    </body>  \n</html> \nInside the socket.html, there is a call to the JavaScript function to be \nexecuted on the form\u2019s  submit. Hence, to serve JavaScript, the \"static\" \nfolder is first mounted. The JavaScript file  ws.js i", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 108}}, {"text": "mit. Hence, to serve JavaScript, the \"static\" \nfolder is first mounted. The JavaScript file  ws.js is placed in the \"static\"  \nfolder. \n \n \nws.js ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 108}}, {"text": "FastAPI \u2013 Python Web Framework \n \n104 \n \nvar ws = new WebSocket(\"ws://localhost:8000/ws\"); \nws.onmessage = function(event) { \n var messages = document.getElementById('messages') \n var message = document.createElement('li') \n var content = document.createTextNode(event.data) \n message.appendChild(content) \n messages.appendChild(message) \n}; \nfunction sendMessage(event) { \n var input = document.getElementById(\"messageText\") \n ws.send(input.value) \n input.value = '' \n event.preventDefault() \n} \nAs ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 109}}, {"text": "lementById(\"messageText\") \n ws.send(input.value) \n input.value = '' \n event.preventDefault() \n} \nAs the JavaScript code is loaded, it creates a websocket listening at \n\"ws://localhost:8000/ws\". The sendMessage() function directs the input \nmessage to the WebSocket URL. \nThis route invokes the websocket_endpoint() function in the application \ncode. The incoming connection request is accepted and the incoming \nmessage is echoed on the client browser.  Add the below code to main.py. \nfrom fastapi i", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 109}}, {"text": "e incoming \nmessage is echoed on the client browser.  Add the below code to main.py. \nfrom fastapi import WebSocket \n@app.websocket(\"/ws\") \nasync def websocket_endpoint(websocket: WebSocket): \n    await websocket.accept() \n    while True: \n        data = await websocket.receive_text() \n        await websocket.send_text(f\"Message text was: {data}\") \nSave the FastAPI code file (main.py), template (socket.html) and JavaScript \nfile (ws.js). Run the Uvicorn server and visit http://localhost:8000/ to", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 109}}, {"text": "ocket.html) and JavaScript \nfile (ws.js). Run the Uvicorn server and visit http://localhost:8000/ to \nrender the chat window as below: ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 109}}, {"text": "FastAPI \u2013 Python Web Framework \n \n105 \n \n \nType a certain text and press Sen d button. The input message will be \nredirected on the browser through the websocket. \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 110}}, {"text": "FastAPI \u2013 Python Web Framework \n \n106 \n \nEvent handlers are the functions to be executed when a certain identified \nevent occurs. In FastAPI, two such events are identified \u2013 startup and \nshutdown. FastAPI\u2019s application object has on_event() decorator that \nuses one of these events as an argument. The function registered with this \ndecorator is fired when the corresponding event occurs. \nThe startup event occurs before the development  server starts and the \nregistered function is typically used", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 111}}, {"text": "up event occurs before the development  server starts and the \nregistered function is typically used to perform certain initialization tasks, \nestablishing connection with the database etc. The event handler of \nshutdown event is called just before the application shutdown. \nExample \nHere is a simpl e example of startup and shutdown event handlers. As the \napp starts, the starting time is echoed in the console log. Similarly, when \nthe server is stopped by pressing ctrl+c, the shutdown time is a", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 111}}, {"text": "n the console log. Similarly, when \nthe server is stopped by pressing ctrl+c, the shutdown time is also \ndisplayed. \nmain.py \nfrom fastapi import FastAPI \nimport datetime \n \napp = FastAPI() \n \n@app.on_event(\"startup\") \nasync def startup_event(): \n    print('Server started :', datetime.datetime.now()) \n \n@app.on_event(\"shutdown\") \nasync def shutdown_event(): \n    print('server Shutdown :', datetime.datetime.now())     \n29. FastAPI \u2013 FastAPI Event Handlers ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 111}}, {"text": ".datetime.now())     \n29. FastAPI \u2013 FastAPI Event Handlers ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 111}}, {"text": "FastAPI \u2013 Python Web Framework \n \n107 \n \nOutput \nIt will produce the following output: \nuvicorn main:app --reload \n \nINFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C \nto quit) \nINFO: Started reloader process [28720] \nINFO: Started server process [28722] \nINFO: Waiting for application startup. \nServer started: 2021-11-23 23:51:45.907691 \nINFO: Application startup complete. \nINFO: Shutting down \nINFO: Waiting for application \nserver Shutdown: 2021-11-23 23:51:50.82955 \nINFO: Applicatio", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 112}}, {"text": "ng down \nINFO: Waiting for application \nserver Shutdown: 2021-11-23 23:51:50.82955 \nINFO: Application shutdown com \nINFO: Finished server process ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 112}}, {"text": "FastAPI \u2013 Python Web Framework \n \n108 \n \nIf you have two independent FastAPI apps, one of them can be mounted on \ntop of the other. The one that is mounted is called a sub -application. The \napp.mount() method adds another completely \"independent\" application \nin a specific path of the main app. It then takes care of handling everything \nunder that path, with the path operations declared in that sub-application. \nLet us first declare a simple FastAPI application object to be used as a top \nlevel", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 113}}, {"text": "ub-application. \nLet us first declare a simple FastAPI application object to be used as a top \nlevel application. \nfrom fastapi import FastAPI \n \napp = FastAPI() \n \n@app.get(\"/app\") \ndef mainindex(): \n    return {\"message\": \"Hello World from Top level app\"} \nThen create another application object subapp and add its own path \noperations. \nsubapp = FastAPI() \n \n@subapp.get(\"/sub\") \ndef subindex(): \n    return {\"message\": \"Hello World from sub app\"} \nMount this subapp object on the main app by usin", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 113}}, {"text": "    return {\"message\": \"Hello World from sub app\"} \nMount this subapp object on the main app by using mount() method. Two \nparameters needed are the URL route and name of the sub application. \napp.mount(\"/subapp\", subapp) \nBoth the main and sub application will have its own docs as can be inspected \nusing Swagger UI. \n30. FastAPI \u2013 Mounting a Sub-App ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 113}}, {"text": "FastAPI \u2013 Python Web Framework \n \n109 \n \n \nThe sub application\u2019s docs are available at \nhttp://localhost:8000/subapp/docs \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 114}}, {"text": "FastAPI \u2013 Python Web Framework \n \n110 \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 115}}, {"text": "FastAPI \u2013 Python Web Framework \n \n111 \n \nA middleware is a function that is processed with every request (before \nbeing processed by any specific path operation) as well as with every \nresponse before returning it.  This function takes each request that comes \nto your application.  It may perform some process with the request by \nrunning a code defined in it and then passes the request to be processed \nby the corresponding operation function. It can also process the response \ngenerated by the op", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 116}}, {"text": "ssed \nby the corresponding operation function. It can also process the response \ngenerated by the operation function before returning it. \nFollowing are some of the middleware available in FastAPI library: \n\uf0b7 CORSMiddleware \n\uf0b7 HTTPSRedirectMiddleware \n\uf0b7 TrustedHostMiddleware \n\uf0b7 GZipMiddleware \nFastAPI provides app.add_middleware() function to handle server errors \nand custom exception handlers. In addition to the above integrated \nmiddleware, it is possible to define a custom middleware. The fol", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 116}}, {"text": " addition to the above integrated \nmiddleware, it is possible to define a custom middleware. The following \nexample defines the addmiddleware() function and decorates it into a \nmiddleware by decorating it with @app.middleware() decorator. \nThe function has two parameters,  the HTTP request object, and the \ncall_next() function that will send the API request to its corresponding \npath and return a response. \nIn addition to the middleware function, the application also has two \noperation function", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 116}}, {"text": " response. \nIn addition to the middleware function, the application also has two \noperation functions. \nimport time \nfrom fastapi import FastAPI, Request \n \napp = FastAPI() \n \n@app.middleware(\"http\") \nasync def addmiddleware(request: Request, call_next): \n    print(\"Middleware works!\") \n31. FastAPI \u2013 Middleware ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 116}}, {"text": "FastAPI \u2013 Python Web Framework \n \n112 \n \n    response = await call_next(request) \n    return response \n@app.get(\"/\") \nasync def index(): \n    return {\"message\":\"Hello World\"} \n \n@app.get(\"/{name}\") \nasync def hello(name:str): \n    return {\"message\":\"Hello \"+name} \nAs the application runs, for each request made by the browser, the \nmiddleware output (Middleware works!) will appear in the console log before \nthe response output. \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 117}}, {"text": "g before \nthe response output. \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 117}}, {"text": "FastAPI \u2013 Python Web Framework \n \n113 \n \nA WSGI application written in Flask or Django framework can be wrapped \nin WSGIMiddleware and mounted it on a FastAPI app to make it ASGI \ncompliant. \nFirst install the Flask package in the current FastAPI environment. \npip3 install flask \nThe following code is a minimal Flask application: \nfrom flask import Flask \nflask_app = Flask(__name__) \n \n@flask_app.route(\"/\") \ndef index_flask(): \n    return \"Hello World from Flask!\" \nThen declare app as a FastAPI ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 118}}, {"text": "route(\"/\") \ndef index_flask(): \n    return \"Hello World from Flask!\" \nThen declare app as a FastAPI application object and define an operation \nfunction for rendering Hello World message. \nfrom fastapi import FastAPI \napp = FastAPI() \n \n@app.get(\"/\") \ndef index(): \n    return {\"message\": \"Hello World from FastAPI!\"} \nNext, mount the flask application as a sub application of FastAPI ma in app \nusing mount() method. \nfrom fastapi.middleware.wsgi import WSGIMiddleware \napp.mount(\"/flask\", WSGIMiddl", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 118}}, {"text": "g mount() method. \nfrom fastapi.middleware.wsgi import WSGIMiddleware \napp.mount(\"/flask\", WSGIMiddleware(flask_app)) \n32. FastAPI \u2013 Mounting Flask App ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 118}}, {"text": "FastAPI \u2013 Python Web Framework \n \n114 \n \nRun the Uvicorn development server. \nuvicorn flaskapp:app \u2013reload \nThe main FastAPI application is available at the URL http://localhost:8000/ \nroute. \n{\"message\":\"Hello World from FastAPI!\"} \nThe Flask sub application is mounted at the URL \nhttp://localhost:8000/flask. \nHello World from Flask! \n ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 119}}, {"text": "FastAPI \u2013 Python Web Framework \n \n115 \n \nSo far, we have been using a local development server \"Uvicorn\" to run our \nFastAPI application. In order to make the application publicly available, it \nmust be deployed on a remote server with a static IP address. It can be \ndeployed to different p latforms such as Heroku, Google Cloud, nginx, etc. \nusing either free plans or subscription based services. \nIn this chapter, we are going to use Deta cloud platform. Its free to use \ndeployment service is ve", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 120}}, {"text": "\nIn this chapter, we are going to use Deta cloud platform. Its free to use \ndeployment service is very easy to use.  \nFirst of all, to use Deta, we need to create an account on its website with a \nsuitable username and password of choice. \n \n33. FastAPI \u2013 Deployment ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 120}}, {"text": "FastAPI \u2013 Python Web Framework \n \n116 \n \nOnce the account is created, install Deta CLI (command line interface) on \nthe local machine. Create a folder for your application (c:\\fastapi_deta_app) \nIf you are using Linux, use the following command in the terminal: \niwr https://get.deta.dev/cli.ps1 -useb | iex \nIf you are using Windows, run the following command from Windows \nPowerShell terminal: \nPS C:\\fastapi_deta_app> iwr https://get.deta.dev/cli.ps1 -useb \n| iex \nDeta was installed successfully ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 121}}, {"text": "C:\\fastapi_deta_app> iwr https://get.deta.dev/cli.ps1 -useb \n| iex \nDeta was installed successfully to \nC:\\Users\\User\\.deta\\bin\\deta.exe \nRun 'deta --help' to get started \nUse the login command and authenticate your username and password. \nPS C:\\fastapi_deta_app> deta login \nPlease, log in from the web page. Waiting... \nhttps://web.deta.sh/cli/60836 \nLogged in successfully. \nIn the same application folder, create a minimal FastAPI application in \nmain.py file \n# main.py \nfrom fastapi import Fast", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 121}}, {"text": "n folder, create a minimal FastAPI application in \nmain.py file \n# main.py \nfrom fastapi import FastAPI \n \napp = FastAPI() \n \n@app.get(\"/\") \ndef read_root(): \n    return {\"Hello\": \"World\"} \n \n@app.get(\"/items/{item_id}\") \ndef read_item(item_id: int): \n    return {\"item_id\": item_id} ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 121}}, {"text": "FastAPI \u2013 Python Web Framework \n \n117 \n \nNow we are ready to deploy our application. Use deta new command from \nthe power shell terminal. \nPS C:\\fastapi_deta_app> deta new \nSuccessfully created a new micro \n{ \n        \"name\": \"fastapi_deta_app\", \n        \"id\": \"2b236e8f-da6a-409b-8d51-7c3952157d3c\", \n        \"project\": \"c03xflte\", \n        \"runtime\": \"python3.9\", \n        \"endpoint\": \"https://vfrjgd.deta.dev\", \n        \"region\": \"ap-southeast-1\", \n        \"visor\": \"enabled\", \n        \"http_auth\"", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 122}}, {"text": "gd.deta.dev\", \n        \"region\": \"ap-southeast-1\", \n        \"visor\": \"enabled\", \n        \"http_auth\": \"disabled\" \n} \nAdding dependencies... \n\u2026.. \nInstalling collected packages: typing-extensions, pydantic, \nidna, sniffio, anyio, starlette, fastapi \nSuccessfully installed anyio-3.4.0 fastapi-0.70.0 idna-3.3 \npydantic-1.8.2 sniffio-1.2.0 starlette-0.16.0 typing-\nextensions-4.0.0 \nDeta deploys the application at the given endpoint (which may be randomly \ncreated for each application). It first inst", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 122}}, {"text": "plication at the given endpoint (which may be randomly \ncreated for each application). It first installs the required dependencies as \nif it is installed on the local machine. After successful deployment, open the \nbrowser and visit the URL as shown in front of endpoint key. The Swagger \nUI documentation can also be found at https://vfrigd.deta.dev/docs. ", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 122}}, {"text": "FastAPI \u2013 Python Web Framework \n \n118 \n \n \n \n \n", "metadata": {"doc_id": "fastapi_tutorial.pdf", "source": "data/users\\user1\\uploads\\fastapi_tutorial.pdf", "page": 123}}]